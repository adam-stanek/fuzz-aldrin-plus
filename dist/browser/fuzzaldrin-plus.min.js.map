{"version":3,"sources":["webpack:///fuzzaldrin-plus.min.js","webpack:///webpack/bootstrap 645e73624e4b16c6ff37","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/scorer.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/pathScorer.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/fuzzaldrin-plus.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/filter.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/matcher.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/query.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","score","string","query","options","preparedQuery","allowErrors","isMatch","core_lw","core_up","string_lw","toLowerCase","computeScore","Math","ceil","subject","query_lw","query_up","length","n","i","j","qj_lw","charCodeAt","qj_up","si","subject_lw","acro","scoreAcronyms","acro_score","count","scoreExact","pos","indexOf","scoreExactMatch","score_row","Array","csc_row","sz","scoreSize","miss_budget","miss_coeff","miss_left","mm","lastIndexOf","csc_invalid","si_lw","charCodes","score_diag","csc_diag","record_miss","score_up","csc_score","start","isWordStart","scoreConsecutives","align","scoreCharacter","curr_s","prev_s","isSeparator","isWordEnd","len","next_s","scorePosition","pos_bonus","sc","max","tau_size","abs","quality","wm","scorePattern","sameCase","end","bonus","posBonus","startOfWord","mi","nj","k","pos2","emptyAcronymResult","sepCount","sumPos","fullWord","isAcronymFullWord","AcronymResult","nbAcronymInQuery","__esModule","default","this","_scorer","scorePath","fullPathScore","useExtensionBonus","pathSeparator","basePos","fileLength","extAdjust","getExtensionScore","ext","depth","basePathScore","slice","alpha","tau_depth","countDir","file_coeff","path","getExtension","str","substr","candidate","startPos","endPos","maxDepth","matched","filter","candidates","parseOptions","_filter","usePathScoring","_pathScorer","match","range","idx","_matcher","wrap","prepareQuery","hasOwnProperty","Object","prototype","key","defaultOptions","preparedQueryCache","_query","Query","_typeof","Symbol","iterator","obj","constructor","fuzzaldrin","defaultPathSeparator","process","toString","platform","window","optCharRegEx","_interopRequireDefault","scoredCandidates","maxResults","maxInners","spotLeft","bKey","scoreProvider","_iterator","_isArray","isArray","_i","_ref","next","done","value","push","sort","sortCandidates","validCandidates","map","pluckCandidates","a","b","_scorer2","_pathScorer2","matches","computeMatch","baseMatches","basenameMatch","mergeMatches","tagClass","tagOpen","tagClose","matchPositions","output","matchIndex","strPos","matchPos","substring","bj","out","ai","offset","arguments","undefined","STOP","UP","LEFT","DIAGONAL","trace","move","backtrack","reverse","coreChars","opt_char_re","replace","truncatedUpperCase","upper","_ref2","char","toUpperCase","getCharCodes","core"],"mappings":"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","file":"fuzzaldrin-plus.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(3);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.score = score;\n\texports.isMatch = isMatch;\n\texports.computeScore = computeScore;\n\texports.isWordStart = isWordStart;\n\texports.isWordEnd = isWordEnd;\n\texports.isSeparator = isSeparator;\n\texports.scorePosition = scorePosition;\n\texports.scoreSize = scoreSize;\n\texports.scoreExact = scoreExact;\n\texports.scorePattern = scorePattern;\n\texports.scoreCharacter = scoreCharacter;\n\texports.scoreConsecutives = scoreConsecutives;\n\texports.scoreExactMatch = scoreExactMatch;\n\texports.scoreAcronyms = scoreAcronyms;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t//\n\t// Score similarity between two string\n\t//\n\t//  isMatch: Fast detection if all character of needle is in haystack\n\t//  score: Find string similarity using a Smith Waterman algorithm\n\t//         Modified to account for programing scenarios (CamelCase folder/file.ext object.property)\n\t//\n\t// Copyright (C) 2015 Jean Christophe Roy and contributors\n\t// MIT License: http://opensource.org/licenses/MIT\n\t\n\t\n\t// Base point for a single character match\n\t// This balance making patterns VS position and size penalty.\n\tvar wm = 150;\n\t\n\t//Fading function\n\tvar pos_bonus = 20; // The character from 0..pos_bonus receive a greater bonus for being at the start of string.\n\tvar tau_size = 85; // Full path length at which the whole match score is halved.\n\t\n\t// Miss count\n\t// When subject[i] is query[j] we register a hit.\n\t// Limiting hit put a boundary on how many permutation we consider to find the best one.\n\t// Helps to speed-up processing of long path and query containing frequent character (eg vowels)\n\t//\n\t// If a spec with frequent repetition fail, increase this.\n\t// This has a direct influence on worst case scenario benchmark.\n\tvar miss_coeff = 0.75; //Max number missed consecutive hit = ceil(miss_coeff*query.length) + 5\n\t\n\t\n\t//\n\t// Main export\n\t//\n\t\n\texports.default = {\n\t\n\t    score: score,\n\t    isMatch: isMatch\n\t\n\t};\n\t\n\t\n\t// Manage the logic of testing if there's a match and calling the main scoring function\n\t// Also manage scoring a path and optional character.\n\t\n\tfunction score(string, query, options) {\n\t    var preparedQuery = options.preparedQuery,\n\t        allowErrors = options.allowErrors;\n\t\n\t    if (!allowErrors && !isMatch(string, preparedQuery.core_lw, preparedQuery.core_up)) {\n\t        return 0;\n\t    }\n\t    var string_lw = string.toLowerCase();\n\t    var score = computeScore(string, string_lw, preparedQuery);\n\t    return Math.ceil(score);\n\t}\n\t\n\t//\n\t// isMatch:\n\t// Are all (non optional)characters of query in subject, in proper order ?\n\t//\n\t\n\tfunction isMatch(subject, query_lw, query_up) {\n\t    var m = subject.length;\n\t    var n = query_lw.length;\n\t\n\t    if (!m || n > m) {\n\t        return false;\n\t    }\n\t\n\t    var i = -1;\n\t    var j = -1;\n\t\n\t    //foreach char of query\n\t    while (++j < n) {\n\t\n\t        var qj_lw = query_lw.charCodeAt(j);\n\t        var qj_up = query_up.charCodeAt(j);\n\t\n\t        // Continue walking the subject from where we have left with previous query char\n\t        // until we have found a character that is either lowercase or uppercase query.\n\t        while (++i < m) {\n\t            var si = subject.charCodeAt(i);\n\t            if (si === qj_lw || si === qj_up) {\n\t                break;\n\t            }\n\t        }\n\t\n\t        // If we passed the last char, query is not in subject\n\t        if (i === m) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    // Found every char of query in subject in proper order, match is positive\n\t    return true;\n\t}\n\t\n\t//----------------------------------------------------------------------\n\t//\n\t// Main scoring algorithm\n\t//\n\t\n\tfunction computeScore(subject, subject_lw, preparedQuery) {\n\t    var query = preparedQuery.query;\n\t    var query_lw = preparedQuery.query_lw;\n\t\n\t\n\t    var m = subject.length;\n\t    var n = query.length;\n\t\n\t    var score = 0;\n\t\n\t    //----------------------------\n\t    // Abbreviations sequence\n\t\n\t    var acro = scoreAcronyms(subject, subject_lw, query, query_lw);\n\t    var acro_score = acro.score;\n\t\n\t    // Whole query is abbreviation ?\n\t    // => use that as score\n\t    if (acro.count === n) {\n\t        return scoreExact(n, m, acro_score, acro.pos);\n\t    }\n\t\n\t    //----------------------------\n\t    // Exact Match ?\n\t    // => use that as score\n\t\n\t    var pos = subject_lw.indexOf(query_lw);\n\t    if (pos > -1) {\n\t        return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);\n\t    }\n\t\n\t    //----------------------------\n\t    // Individual characters\n\t    // (Smith Waterman algorithm)\n\t\n\t\n\t    //Init\n\t    var score_row = new Array(n);\n\t    var csc_row = new Array(n);\n\t    var sz = scoreSize(n, m);\n\t\n\t    var miss_budget = Math.ceil(miss_coeff * n) + 5;\n\t    var miss_left = miss_budget;\n\t\n\t    //Fill with 0\n\t    var j = -1;\n\t    while (++j < n) {\n\t        score_row[j] = 0;\n\t        csc_row[j] = 0;\n\t    }\n\t\n\t    // Limit the search to the active region\n\t    // for example with query `abc`, subject `____a_bc_ac_c____`\n\t    // there's a region before first `a` and after last `c`\n\t    // that can be simplified out of the matching process\n\t\n\t    // Before first occurrence in subject of first letter of query, or -1\n\t    var i = subject_lw.indexOf(query_lw[0]);\n\t    if (i > -1) {\n\t        i--;\n\t    }\n\t\n\t    // After last occurrence of last letter of query,\n\t    var mm = subject_lw.lastIndexOf(query_lw[n - 1], m);\n\t    if (mm > i) {\n\t        m = mm + 1;\n\t    }\n\t\n\t    var csc_invalid = true;\n\t\n\t    while (++i < m) {\n\t        //foreach char si of subject\n\t        var si_lw = subject_lw[i];\n\t\n\t        // if si_lw is not in query\n\t        if (preparedQuery.charCodes[si_lw.charCodeAt(0)] == null) {\n\t            // reset csc_row and move to next\n\t            if (csc_invalid !== true) {\n\t                j = -1;\n\t                while (++j < n) {\n\t                    csc_row[j] = 0;\n\t                }\n\t                csc_invalid = true;\n\t            }\n\t            continue;\n\t        }\n\t\n\t        score = 0;\n\t        var score_diag = 0;\n\t        var csc_diag = 0;\n\t        var record_miss = true;\n\t        csc_invalid = false;\n\t\n\t        j = -1; //0..n-1\n\t        while (++j < n) {\n\t            //foreach char qj of query\n\t\n\t            // What is the best gap ?\n\t            // score_up contain the score of a gap in subject.\n\t            // score_left = last iteration of score, -> gap in query.\n\t            var score_up = score_row[j];\n\t            if (score_up > score) {\n\t                score = score_up;\n\t            }\n\t\n\t            //Reset consecutive\n\t            var csc_score = 0;\n\t\n\t            //Compute a tentative match\n\t            if (query_lw[j] === si_lw) {\n\t\n\t                var start = isWordStart(i, subject, subject_lw);\n\t\n\t                // Forward search for a sequence of consecutive char\n\t                csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n\t\n\t                // Determine bonus for matching A[i] with B[j]\n\t                var align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n\t\n\t                //Are we better using this match or taking the best gap (currently stored in score)?\n\t                if (align > score) {\n\t                    score = align;\n\t                    // reset consecutive missed hit count\n\t                    miss_left = miss_budget;\n\t                } else {\n\t                    // We rejected this match and record a miss.\n\t                    // If budget is exhausted exit\n\t                    if (record_miss && --miss_left <= 0) {\n\t                        return score_row[n - 1] * sz;\n\t                    }\n\t                    record_miss = false;\n\t                }\n\t            }\n\t\n\t            //Prepare next sequence & match score.\n\t            score_diag = score_up;\n\t            csc_diag = csc_row[j];\n\t            csc_row[j] = csc_score;\n\t            score_row[j] = score;\n\t        }\n\t    }\n\t\n\t    // get highest score so far\n\t    score = score_row[n - 1];\n\t    return score * sz;\n\t}\n\t\n\t//\n\t// Boundaries\n\t//\n\t// Is the character at the start of a word, end of the word, or a separator ?\n\t// Fortunately those small function inline well.\n\t//\n\t\n\tfunction isWordStart(pos, subject, subject_lw) {\n\t    if (pos === 0) {\n\t        return true;\n\t    } // match is FIRST char ( place a virtual token separator before first char of string)\n\t    var curr_s = subject[pos];\n\t    var prev_s = subject[pos - 1];\n\t    return isSeparator(prev_s) || // match FOLLOW a separator\n\t    curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1]; // match is Capital in camelCase (preceded by lowercase)\n\t}\n\t\n\tfunction isWordEnd(pos, subject, subject_lw, len) {\n\t    if (pos === len - 1) {\n\t        return true;\n\t    } // last char of string\n\t    var curr_s = subject[pos];\n\t    var next_s = subject[pos + 1];\n\t    return isSeparator(next_s) || // match IS FOLLOWED BY a separator\n\t    curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1]; // match is lowercase, followed by uppercase\n\t}\n\t\n\tfunction isSeparator(c) {\n\t    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\\\';\n\t}\n\t//\n\t// Scoring helper\n\t//\n\t\n\tfunction scorePosition(pos) {\n\t    if (pos < pos_bonus) {\n\t        var sc = pos_bonus - pos;\n\t        return 100 + sc * sc;\n\t    } else {\n\t        return Math.max(100 + pos_bonus - pos, 0);\n\t    }\n\t}\n\t\n\tfunction scoreSize(n, m) {\n\t    // Size penalty, use the difference of size (m-n)\n\t    return tau_size / (tau_size + Math.abs(m - n));\n\t}\n\t\n\tfunction scoreExact(n, m, quality, pos) {\n\t    return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);\n\t}\n\t\n\t//\n\t// Shared scoring logic between exact match, consecutive & acronym\n\t// Ensure pattern length dominate the score then refine to take into account case-sensitivity\n\t// and structural quality of the pattern on the overall string (word boundary)\n\t//\n\t\n\tfunction scorePattern(count, len, sameCase, start, end) {\n\t    var sz = count;\n\t\n\t    var bonus = 6; // to ensure consecutive length dominate score, this should be as large other bonus combined\n\t    if (sameCase === count) {\n\t        bonus += 2;\n\t    }\n\t    if (start) {\n\t        bonus += 3;\n\t    }\n\t    if (end) {\n\t        bonus += 1;\n\t    }\n\t\n\t    if (count === len) {\n\t        // when we match 100% of query we allow to break the size ordering.\n\t        // This is to help exact match bubble up vs size, depth penalty etc\n\t        if (start) {\n\t            if (sameCase === len) {\n\t                sz += 2;\n\t            } else {\n\t                sz += 1;\n\t            }\n\t        }\n\t        if (end) {\n\t            bonus += 1;\n\t        }\n\t    }\n\t\n\t    return sameCase + sz * (sz + bonus);\n\t}\n\t\n\t//\n\t// Compute the bonuses for two chars that are confirmed to matches in a case-insensitive way\n\t//\n\t\n\tfunction scoreCharacter(i, j, start, acro_score, csc_score) {\n\t\n\t    // start of string / position of match bonus\n\t    var posBonus = scorePosition(i);\n\t\n\t    // match IS a word boundary\n\t    // choose between taking part of consecutive characters or consecutive acronym\n\t    if (start) {\n\t        return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);\n\t    }\n\t\n\t    // normal Match\n\t    return posBonus + wm * csc_score;\n\t}\n\t\n\t//\n\t// Forward search for a sequence of consecutive character.\n\t//\n\t\n\tfunction scoreConsecutives(subject, subject_lw, query, query_lw, i, j, startOfWord) {\n\t    var m = subject.length;\n\t    var n = query.length;\n\t\n\t    var mi = m - i;\n\t    var nj = n - j;\n\t    var k = mi < nj ? mi : nj;\n\t\n\t    var sameCase = 0;\n\t    var sz = 0; //sz will be one more than the last qi is sj\n\t\n\t    // query_lw[i] is subject_lw[j] has been checked before entering now do case sensitive check.\n\t    if (query[j] === subject[i]) {\n\t        sameCase++;\n\t    }\n\t\n\t    //Continue while lowercase char are the same, record when they are case-sensitive match.\n\t    while (++sz < k && query_lw[++j] === subject_lw[++i]) {\n\t        if (query[j] === subject[i]) {\n\t            sameCase++;\n\t        }\n\t    }\n\t\n\t    // Faster path for single match.\n\t    // Isolated character match occurs often and are not really interesting.\n\t    // Fast path so we don't compute expensive pattern score on them.\n\t    // Acronym should be addressed with acronym context bonus instead of consecutive.\n\t    if (sz === 1) {\n\t        return 1 + 2 * sameCase;\n\t    }\n\t\n\t    return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));\n\t}\n\t\n\t//\n\t// Compute the score of an exact match at position pos.\n\t//\n\t\n\tfunction scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m) {\n\t\n\t    // Test for word start\n\t    var start = isWordStart(pos, subject, subject_lw);\n\t\n\t    // Heuristic\n\t    // If not a word start, test next occurrence\n\t    // - We want exact match to be fast\n\t    // - For exact match, word start has the biggest impact on score.\n\t    // - Testing 2 instances is somewhere between testing only one and testing every instances.\n\t\n\t    if (!start) {\n\t        var pos2 = subject_lw.indexOf(query_lw, pos + 1);\n\t        if (pos2 > -1) {\n\t            start = isWordStart(pos2, subject, subject_lw);\n\t            if (start) {\n\t                pos = pos2;\n\t            }\n\t        }\n\t    }\n\t\n\t    //Exact case bonus.\n\t    var i = -1;\n\t    var sameCase = 0;\n\t    while (++i < n) {\n\t        if (query[pos + i] === subject[i]) {\n\t            sameCase++;\n\t        }\n\t    }\n\t\n\t    var end = isWordEnd(pos + n - 1, subject, subject_lw, m);\n\t\n\t    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);\n\t}\n\t\n\t//\n\t// Acronym prefix\n\t//\n\t\n\t\n\tvar AcronymResult = function AcronymResult(score, pos, count) {\n\t    _classCallCheck(this, AcronymResult);\n\t\n\t    this.score = score;\n\t    this.pos = pos;\n\t    this.count = count;\n\t};\n\t\n\tvar emptyAcronymResult = new AcronymResult(0, 0.1, 0);\n\t\n\tfunction scoreAcronyms(subject, subject_lw, query, query_lw) {\n\t    var m = subject.length;\n\t    var n = query.length;\n\t\n\t    //a single char is not an acronym\n\t    if (m <= 1 || n <= 1) {\n\t        return emptyAcronymResult;\n\t    }\n\t\n\t    var count = 0;\n\t    var sepCount = 0;\n\t    var sumPos = 0;\n\t    var sameCase = 0;\n\t\n\t    var i = -1;\n\t    var j = -1;\n\t\n\t    //foreach char of query\n\t    while (++j < n) {\n\t\n\t        var qj_lw = query_lw[j];\n\t\n\t        // Separator will not score point but will continue the prefix when present.\n\t        // Test that the separator is in the candidate and advance cursor to that position.\n\t        // If no separator break the prefix\n\t\n\t        if (isSeparator(qj_lw)) {\n\t            i = subject_lw.indexOf(qj_lw, i + 1);\n\t            if (i > -1) {\n\t                sepCount++;\n\t                continue;\n\t            } else {\n\t                break;\n\t            }\n\t        }\n\t\n\t        // For other characters we search for the first match where subject[i] = query[j]\n\t        // that also happens to be a start-of-word\n\t\n\t        while (++i < m) {\n\t            if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {\n\t                if (query[j] === subject[i]) {\n\t                    sameCase++;\n\t                }\n\t                sumPos += i;\n\t                count++;\n\t                break;\n\t            }\n\t        }\n\t\n\t        // All of subject is consumed, stop processing the query.\n\t        if (i === m) {\n\t            break;\n\t        }\n\t    }\n\t\n\t    // Here, all of query is consumed (or we have reached a character not in acronym)\n\t    // A single character is not an acronym (also prevent division by 0)\n\t    if (count < 2) {\n\t        return emptyAcronymResult;\n\t    }\n\t\n\t    // Acronym are scored as start-of-word\n\t    // Unless the acronym is a 1:1 match with candidate then it is upgraded to full-word.\n\t    var fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;\n\t    var score = scorePattern(count, n, sameCase, true, fullWord);\n\t\n\t    return new AcronymResult(score, sumPos / count, count + sepCount);\n\t}\n\t\n\t//\n\t// Test whether there's a 1:1 relationship between query and acronym of candidate.\n\t// For that to happens\n\t// (a) All character of query must be matched to an acronym of candidate\n\t// (b) All acronym of candidate must be matched to a character of query.\n\t//\n\t// This method check for (b) assuming (a) has been checked before entering.\n\t\n\tfunction isAcronymFullWord(subject, subject_lw, query, nbAcronymInQuery) {\n\t    var m = subject.length;\n\t    var n = query.length;\n\t    var count = 0;\n\t\n\t    // Heuristic:\n\t    // Assume one acronym every (at most) 12 character on average\n\t    // This filter out long paths, but then they can match on the filename.\n\t    if (m > 12 * n) {\n\t        return false;\n\t    }\n\t\n\t    var i = -1;\n\t    while (++i < m) {\n\t        //For each char of subject\n\t        //Test if we have an acronym, if so increase acronym count.\n\t        //If the acronym count is more than nbAcronymInQuery (number of non separator char in query)\n\t        //Then we do not have 1:1 relationship.\n\t        if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    return true;\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.score = score;\n\texports.countDir = countDir;\n\texports.getExtension = getExtension;\n\texports.getExtensionScore = getExtensionScore;\n\t\n\tvar _scorer = __webpack_require__(1);\n\t\n\tvar tau_depth = 13; //  Directory depth at which the full path influence is halved.\n\tvar file_coeff = 1.2; //  Full path is also penalized for length of basename. This adjust a scale factor for that penalty.\n\t\n\texports.default = {\n\t    score: score,\n\t    countDir: countDir,\n\t    getExtensionScore: getExtensionScore\n\t};\n\t\n\t//  Manage the logic of testing if there's a match and calling the main scoring function\n\t//  Also manage scoring a path and optional character.\n\t\n\tfunction score(string, query, options) {\n\t    var preparedQuery = options.preparedQuery,\n\t        allowErrors = options.allowErrors;\n\t\n\t    if (!allowErrors && !(0, _scorer.isMatch)(string, preparedQuery.core_lw, preparedQuery.core_up)) {\n\t        return 0;\n\t    }\n\t    var string_lw = string.toLowerCase();\n\t    var score = (0, _scorer.computeScore)(string, string_lw, preparedQuery);\n\t    score = scorePath(string, string_lw, score, options);\n\t    return Math.ceil(score);\n\t}\n\t\n\t// \n\t//  Score adjustment for path\n\t// \n\t\n\tfunction scorePath(subject, subject_lw, fullPathScore, options) {\n\t\n\t    if (fullPathScore === 0) {\n\t        return 0;\n\t    }\n\t\n\t    var preparedQuery = options.preparedQuery,\n\t        useExtensionBonus = options.useExtensionBonus,\n\t        pathSeparator = options.pathSeparator;\n\t\n\t    //  Skip trailing slashes\n\t\n\t    var end = subject.length - 1;\n\t    while (subject[end] === pathSeparator) {\n\t        end--;\n\t    }\n\t\n\t    //  Get position of basePath of subject.\n\t    var basePos = subject.lastIndexOf(pathSeparator, end);\n\t    var fileLength = end - basePos;\n\t\n\t    //  Get a bonus for matching extension\n\t    var extAdjust = 1.0;\n\t\n\t    if (useExtensionBonus) {\n\t        extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);\n\t        fullPathScore *= extAdjust;\n\t    }\n\t\n\t    //  no basePath, nothing else to compute.\n\t    if (basePos === -1) {\n\t        return fullPathScore;\n\t    }\n\t\n\t    //  Get the number of folder in query\n\t    var depth = preparedQuery.depth;\n\t\n\t    //  Get that many folder from subject\n\t\n\t    while (basePos > -1 && depth-- > 0) {\n\t        basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n\t    }\n\t\n\t    //  Get basePath score, if BaseName is the whole string, no need to recompute\n\t    //  We still need to apply the folder depth and filename penalty.\n\t    var basePathScore = basePos === -1 ? fullPathScore : extAdjust * (0, _scorer.computeScore)(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery);\n\t\n\t    //  Final score is linear interpolation between base score and full path score.\n\t    //  For low directory depth, interpolation favor base Path then include more of full path as depth increase\n\t    //\n\t    //  A penalty based on the size of the basePath is applied to fullPathScore\n\t    //  That way, more focused basePath match can overcome longer directory path.\n\t\n\t    var alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1, pathSeparator));\n\t    return alpha * basePathScore + (1 - alpha) * fullPathScore * (0, _scorer.scoreSize)(0, file_coeff * fileLength);\n\t}\n\t\n\t// \n\t//  Count number of folder in a path.\n\t//  (consecutive slashes count as a single directory)\n\t// \n\t\n\tfunction countDir(path, end, pathSeparator) {\n\t    if (end < 1) {\n\t        return 0;\n\t    }\n\t\n\t    var count = 0;\n\t    var i = -1;\n\t\n\t    // skip slash at the start so `foo/bar` and `/foo/bar` have the same depth.\n\t    while (++i < end && path[i] === pathSeparator) {}\n\t\n\t    while (++i < end) {\n\t        if (path[i] === pathSeparator) {\n\t            count++; // record first slash, but then skip consecutive ones\n\t            while (++i < end && path[i] === pathSeparator) {}\n\t        }\n\t    }\n\t\n\t    return count;\n\t}\n\t\n\t// \n\t//  Find fraction of extension that is matched by query.\n\t//  For example mf.h prefers myFile.h to myfile.html\n\t//  This need special handling because it give point for not having characters (the `tml` in above example)\n\t// \n\t\n\tfunction getExtension(str) {\n\t    var pos = str.lastIndexOf(\".\");\n\t    if (pos < 0) {\n\t        return \"\";\n\t    } else {\n\t        return str.substr(pos + 1);\n\t    }\n\t}\n\t\n\tfunction getExtensionScore(candidate, ext, startPos, endPos, maxDepth) {\n\t    //  startPos is the position of last slash of candidate, -1 if absent.\n\t\n\t    if (ext == null || !ext.length) {\n\t        return 0;\n\t    }\n\t\n\t    //  Check that (a) extension exist, (b) it is after the start of the basename\n\t    var pos = candidate.lastIndexOf(\".\", endPos);\n\t    if (pos <= startPos) {\n\t        return 0;\n\t    } //  (note that startPos >= -1)\n\t\n\t    var n = ext.length;\n\t    var m = endPos - pos;\n\t\n\t    //  n contain the smallest of both extension length, m the largest.\n\t    if (m < n) {\n\t        n = m;\n\t        m = ext.length;\n\t    }\n\t\n\t    // place cursor after dot & count number of matching characters in extension\n\t    pos++;\n\t    var matched = -1;\n\t    while (++matched < n) {\n\t        if (candidate[pos + matched] !== ext[matched]) {\n\t            break;\n\t        }\n\t    }\n\t\n\t    //  if nothing found, try deeper for multiple extensions, with some penalty for depth\n\t    if (matched === 0 && maxDepth > 0) {\n\t        return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);\n\t    }\n\t\n\t    //  cannot divide by zero because m is the largest extension length and we return if either is 0\n\t    return matched / m;\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\texports.filter = filter;\n\texports.score = score;\n\texports.match = match;\n\texports.wrap = wrap;\n\texports.prepareQuery = prepareQuery;\n\t\n\tvar _filter = __webpack_require__(4);\n\t\n\tvar _scorer = __webpack_require__(1);\n\t\n\tvar _pathScorer = __webpack_require__(2);\n\t\n\tvar _matcher = __webpack_require__(5);\n\t\n\tvar _query = __webpack_require__(6);\n\t\n\tvar fuzzaldrin = {\n\t    filter: filter,\n\t    score: score,\n\t    match: match,\n\t    wrap: wrap,\n\t    prepareQuery: prepareQuery\n\t};\n\t\n\texports.default = fuzzaldrin;\n\t\n\t\n\tvar preparedQueryCache = null;\n\t\n\t/**\r\n\t * Filter:\r\n\t *  Given a list of candidate, output a list of candidate that match query.\r\n\t *  Output list is the same format (string or object) than input list.\r\n\t *\r\n\t *  If given a list of object, specify options.key as the property `candidate[key]`\r\n\t *  that contain the string representation of the candidate\r\n\t *\r\n\t *  Output is sorted by match score.\r\n\t *\r\n\t * @param {Array.<(string|object)>} candidates - array of string or objects\r\n\t * @param {string} query - string to search for in each candidate\r\n\t * @param {FilterOptions=} options - (optional) see option hash doc\r\n\t * @returns {Array.<(string|object)>} - filtered & sorted subset of input candidates\r\n\t */\n\t\n\tfunction filter(candidates, query, options) {\n\t\n\t    if (query == null || !query.length) return [];\n\t    if (candidates == null || !candidates.length) return [];\n\t    options = parseOptions(options, query);\n\t    return (0, _filter.filter)(candidates, query, options);\n\t}\n\t\n\t/**\r\n\t * Score:\r\n\t *   Give the numerical score on how a given string match query.\r\n\t *\r\n\t *   This is provided so you can build your own filter method.\r\n\t *   For example you may have a special way to iterate candidate,\r\n\t *   access candidate string representation, or you may need to\r\n\t *   modify the score to account external knowledge (eg last modified date)\r\n\t *\r\n\t * @param {string} string - string representation of a candidate\r\n\t * @param {string} query - string to search for in candidate\r\n\t * @param {ScoringOptions=} options - (optional) see option hash doc\r\n\t * @returns {number} score 0 .. max, where max is score(string, string)\r\n\t */\n\t\n\tfunction score(string, query, options) {\n\t\n\t    if (string == null || !string.length) return 0;\n\t    if (query == null || !query.length) return 0;\n\t\n\t    options = parseOptions(options, query);\n\t\n\t    if (options.usePathScoring) {\n\t        return (0, _pathScorer.score)(string, query, options);\n\t    } else {\n\t        return (0, _scorer.score)(string, query, options);\n\t    }\n\t}\n\t\n\t/**\r\n\t * Match:\r\n\t *    Communicate which characters of candidate where selected by the algorithm to represent the query.\r\n\t *    The match function output an array of character position.\r\n\t *    If you need to display those character as an html string see wrap function.\r\n\t *\r\n\t * @param {string} string - string representation of a candidate\r\n\t * @param {string} query - string to search for in candidate\r\n\t * @param {MatchOptions=} options (optional)\r\n\t * @returns {Array.<number>}\r\n\t */\n\t\n\tfunction match(string, query, options) {\n\t\n\t    if (string == null || !string.length) return [];\n\t    if (query == null || !query.length) return [];\n\t\n\t    //If both are the same, return an array of consecutive numbers\n\t    if (string === query) {\n\t        var length = string.length;\n\t        var range = new Array(length);\n\t        for (var idx = 0; idx < length; idx++) {\n\t            range[idx] = idx;\n\t        }\n\t        return range;\n\t    }\n\t\n\t    options = parseOptions(options, query);\n\t    return (0, _matcher.match)(string, query, options);\n\t}\n\t\n\t/**\r\n\t * Wrap:\r\n\t *    Communicate which characters of candidate where selected by the algorithm to represent the query.\r\n\t *    This function output the given string with chosen character wrapped in a delimiter string (eg html tag).\r\n\t *\r\n\t *    To control the wrap use the option hash.\r\n\t *    Here are some default value:\r\n\t *      options.tagOpen = `<strong class=\"highlight\">`\r\n\t *      options.tagClose = `</strong>`\r\n\t *\r\n\t *    Alternatively, if you chose to keep the default tagOpen,\r\n\t *    you can specify option.tagClass and change the `highlight`\r\n\t *    class to one of your choosing.\r\n\t *\r\n\t *    Wrap method will try to group consecutive matches under the same tag.\r\n\t *\r\n\t * @param {string} string - string representation of a candidate\r\n\t * @param {string} query - string to search for in candidate\r\n\t * @param {WrapOptions=} options\r\n\t * @returns {string} - input string with match wrapped in open and close tag.\r\n\t */\n\t\n\tfunction wrap(string, query, options) {\n\t\n\t    if (string == null || !string.length) return \"\";\n\t    if (query == null || !query.length) return \"\";\n\t\n\t    options = parseOptions(options, query);\n\t    return (0, _matcher.wrap)(string, query, options);\n\t}\n\t\n\t/**\r\n\t * PrepareQuery:\r\n\t *   The usual scenario is to compare a single query with multiple candidate.\r\n\t *   To speed that process up, we pre-compute some information about the query.\r\n\t *\r\n\t *   Pre-computed query is natural to use in bulk method like filter, but harder\r\n\t *   in one-by-one method like score or match. To keep those method fast you can give\r\n\t *   a pre computed query in option hash as `options.preparedQuery`\r\n\t *\r\n\t *   Note that we use an internal cache `preparedQueryCache` that cover most of the simple cases\r\n\t *   So this method may not be needed in thos cases.\r\n\t *\r\n\t * @param {string} query\r\n\t * @param {QueryOptions} options\r\n\t * @returns {Query}\r\n\t */\n\t\n\tfunction prepareQuery(query, options) {\n\t    options = parseOptions(options, query);\n\t    return options.preparedQuery;\n\t}\n\t\n\t//\n\t// Detect node.js or browser to set default path separator\n\t//\n\t\n\tvar defaultPathSeparator = \"/\";\n\t\n\tif ((typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === 'object' && Object.prototype.toString.call(process) === '[object process]') {\n\t\n\t    // On node js we assume the list of candidates match local OS path format.\n\t    // See comment bellow to change behavior.\n\t    defaultPathSeparator = process.platform === \"win32\" ? '\\\\' : '/';\n\t} else if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' && Object.prototype.toString.call(window) === \"[object Window]\") {\n\t\n\t    // We assume that browser are dealing with url, if assumption is false use option hash like so:\n\t    // fuzzaldrin.filter( candidates, query, {pathSeparator: platformSep} )\n\t    // and determine `platformSep` any so it match the format of candidates.\n\t\n\t    defaultPathSeparator = \"/\";\n\t\n\t    // Export main object to global window.\n\t    window.fuzzaldrin = fuzzaldrin;\n\t}\n\t\n\t//\n\t// Setup default values\n\t//\n\t\n\t/**\r\n\t * @type {ScoringOptions}\r\n\t */\n\tvar defaultOptions = {\n\t    allowErrors: false,\n\t    usePathScoring: true,\n\t    useExtensionBonus: false,\n\t    pathSeparator: defaultPathSeparator,\n\t    optCharRegEx: null,\n\t    preparedQuery: null\n\t};\n\t\n\t/**\r\n\t *\r\n\t * @param {(ScoringOptions|FilterOptions|MatchOptions|WrapOptions)} options\r\n\t * @param {string} query\r\n\t * @returns {(ScoringOptions|FilterOptions|MatchOptions|WrapOptions)} options completed with default values from ScoringOptions\r\n\t */\n\tfunction parseOptions(options, query) {\n\t\n\t    // If no options given, copy default\n\t    // Else merge options with defaults.\n\t\n\t    if (options == null) options = {};\n\t\n\t    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\t    for (var key in defaultOptions) {\n\t        if (hasOwnProperty.call(defaultOptions, key) && !hasOwnProperty.call(options, key)) {\n\t            options[key] = defaultOptions[key];\n\t        }\n\t    }\n\t\n\t    // if preparedQuery is given use it\n\t    // else assign from cache, recompute cache if needed\n\t    if (options.preparedQuery == null) {\n\t\n\t        if (preparedQueryCache == null || preparedQueryCache.query !== query) {\n\t            preparedQueryCache = new _query.Query(query, options);\n\t        }\n\t        options.preparedQuery = preparedQueryCache;\n\t    }\n\t\n\t    return options;\n\t}\n\t\n\t//\n\t// Documentation for option hash\n\t//\n\t\n\t/**\r\n\t * @typedef {Object} QueryOptions\r\n\t * @property {string} pathSeparator - If candidate are path, indicate path seperator used.\r\n\t * @property {RegExp} optCharRegEx - Some characters do not have to match exactly, example `space`.\r\n\t *\r\n\t */\n\t\n\t/**\r\n\t * @typedef {Object} ScoringOptions\r\n\t * @extends QueryOptions\r\n\t *\r\n\t * @property {boolean} allowErrors - Should we allow candidates that does not have all characters of query ?\r\n\t * @property {boolean} usePathScoring - Should we try to interpret candidates as path\r\n\t * @property {boolean} useExtensionBonus - Should we try to interpret extension from query\r\n\t *                                         and prefer files that match that extension (needs usePathScoring)\r\n\t * @property {Query} preparedQuery - If you have a precomputed query object set it here.\r\n\t */\n\t\n\t/**\r\n\t * @typedef {Object} FilterOptions\r\n\t * @extends ScoringOptions\r\n\t *\r\n\t * @property {string} key - Object are given, this is the key of object that contain the string to be scored.\r\n\t * @property {number} maxResults - Output the top `maxResults` best results at most.\r\n\t * @property {number} maxInners - Speed vs correctness optimisation: stop filtering after that many positive results\r\n\t */\n\t\n\t/**\r\n\t * @typedef {Object} MatchOptions\r\n\t * @extends ScoringOptions\r\n\t *\r\n\t *\r\n\t */\n\t\n\t/**\r\n\t * @typedef {Object} WrapOptions\r\n\t * @extends MatchOptions\r\n\t *\r\n\t * @property {string} tagOpen - string to place before a match default to `<strong class=\"highlight\">`\r\n\t * @property {string} tagClose - string to place after a match default to `</strong>`\r\n\t * @property {string} tagClass - change the class of the default open tag (tagOpen must be unset)\r\n\t *\r\n\t */\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.filter = filter;\n\t\n\tvar _scorer = __webpack_require__(1);\n\t\n\tvar _scorer2 = _interopRequireDefault(_scorer);\n\t\n\tvar _pathScorer = __webpack_require__(2);\n\t\n\tvar _pathScorer2 = _interopRequireDefault(_pathScorer);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t    filter: filter\n\t};\n\tfunction filter(candidates, query, options) {\n\t    var scoredCandidates = [];\n\t\n\t    // See also option parsing on main module for default\n\t    var key = options.key,\n\t        maxResults = options.maxResults,\n\t        maxInners = options.maxInners,\n\t        usePathScoring = options.usePathScoring;\n\t\n\t    var spotLeft = maxInners != null && maxInners > 0 ? maxInners : candidates.length + 1;\n\t    var bKey = key != null;\n\t    var scoreProvider = usePathScoring ? _pathScorer2.default : _scorer2.default;\n\t\n\t    for (var _iterator = candidates, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n\t        var _ref;\n\t\n\t        if (_isArray) {\n\t            if (_i >= _iterator.length) break;\n\t            _ref = _iterator[_i++];\n\t        } else {\n\t            _i = _iterator.next();\n\t            if (_i.done) break;\n\t            _ref = _i.value;\n\t        }\n\t\n\t        var candidate = _ref;\n\t\n\t\n\t        // Get the candidate value\n\t        var string = bKey ? candidate[key] : candidate;\n\t        if (string == null || !string.length) {\n\t            continue;\n\t        }\n\t\n\t        // Get score, If score greater than 0 add to valid results\n\t        var score = scoreProvider.score(string, query, options);\n\t        if (score > 0) {\n\t            scoredCandidates.push({ candidate: candidate, score: score });\n\t            spotLeft -= 1;\n\t            if (spotLeft <= 0) {\n\t                break;\n\t            }\n\t        }\n\t    }\n\t\n\t    //  Sort scores in descending order\n\t    scoredCandidates.sort(sortCandidates);\n\t\n\t    // Extract original candidate\n\t    var validCandidates = scoredCandidates.map(pluckCandidates);\n\t\n\t    // Trim to maxResults if specified\n\t    if (maxResults != null) {\n\t        validCandidates = candidates.slice(0, maxResults);\n\t    }\n\t\n\t    // And return\n\t    return validCandidates;\n\t}\n\t\n\tfunction pluckCandidates(a) {\n\t    return a.candidate;\n\t}\n\tfunction sortCandidates(a, b) {\n\t    return b.score - a.score;\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.match = match;\n\texports.wrap = wrap;\n\t\n\tvar _scorer = __webpack_require__(1);\n\t\n\texports.default = {\n\t    match: match,\n\t    wrap: wrap\n\t};\n\t\n\t// Return position of character which matches\n\t\n\t// A match list is an array of indexes to characters that match.\n\t// This file should closely follow `scorer` except that it returns an array\n\t// of indexes instead of a score.\n\t\n\tfunction match(string, query, options) {\n\t    var allowErrors = options.allowErrors,\n\t        preparedQuery = options.preparedQuery,\n\t        pathSeparator = options.pathSeparator;\n\t\n\t\n\t    if (!allowErrors && !(0, _scorer.isMatch)(string, preparedQuery.core_lw, preparedQuery.core_up)) {\n\t        return [];\n\t    }\n\t    var string_lw = string.toLowerCase();\n\t\n\t    // Full path results\n\t    var matches = computeMatch(string, string_lw, preparedQuery);\n\t\n\t    //if there is no matches on the full path, there should not be any on the base path either.\n\t    if (matches.length === 0) {\n\t        return matches;\n\t    }\n\t\n\t    // Is there a base path ?\n\t    if (string.indexOf(pathSeparator) > -1) {\n\t\n\t        // Base path results\n\t        var baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);\n\t\n\t        // Combine the results, removing duplicate indexes\n\t        matches = mergeMatches(matches, baseMatches);\n\t    }\n\t\n\t    return matches;\n\t}\n\t\n\t//\n\t// Wrap\n\t//\n\t// Helper around match if you want a string with result wrapped by some delimiter text\n\t\n\tfunction wrap(string, query, options) {\n\t\n\t    var tagClass = options.tagClass || 'highlight';\n\t    var tagOpen = options.tagOpen || '<strong class=\"' + tagClass + '\">';\n\t    var tagClose = options.tagClose || '</strong>';\n\t\n\t    if (string === query) {\n\t        return tagOpen + string + tagClose;\n\t    }\n\t\n\t    //Run get position where a match is found\n\t    var matchPositions = match(string, query, options);\n\t\n\t    //If no match return as is\n\t    if (matchPositions.length === 0) {\n\t        return string;\n\t    }\n\t\n\t    //Loop over match positions\n\t    var output = '';\n\t    var matchIndex = -1;\n\t    var strPos = 0;\n\t    while (++matchIndex < matchPositions.length) {\n\t        var matchPos = matchPositions[matchIndex];\n\t\n\t        // Get text before the current match position\n\t        if (matchPos > strPos) {\n\t            output += string.substring(strPos, matchPos);\n\t            strPos = matchPos;\n\t        }\n\t\n\t        // Get consecutive matches to wrap under a single tag\n\t        while (++matchIndex < matchPositions.length) {\n\t            if (matchPositions[matchIndex] === matchPos + 1) {\n\t                matchPos++;\n\t            } else {\n\t                matchIndex--;\n\t                break;\n\t            }\n\t        }\n\t\n\t        //Get text inside the match, including current character\n\t        matchPos++;\n\t        if (matchPos > strPos) {\n\t            output += tagOpen;\n\t            output += string.substring(strPos, matchPos);\n\t            output += tagClose;\n\t            strPos = matchPos;\n\t        }\n\t    }\n\t\n\t    //Get string after last match\n\t    if (strPos < string.length - 1) {\n\t        output += string.substring(strPos);\n\t    }\n\t\n\t    //return wrapped text\n\t    return output;\n\t}\n\t\n\tfunction basenameMatch(subject, subject_lw, preparedQuery, pathSeparator) {\n\t\n\t    // Skip trailing slashes\n\t    var end = subject.length - 1;\n\t    while (subject[end] === pathSeparator) {\n\t        end--;\n\t    }\n\t\n\t    // Get position of basePath of subject.\n\t    var basePos = subject.lastIndexOf(pathSeparator, end);\n\t\n\t    //If no PathSeparator, no base path exist.\n\t    if (basePos === -1) {\n\t        return [];\n\t    }\n\t\n\t    // Get the number of folder in query\n\t    var depth = preparedQuery.depth;\n\t\n\t    // Get that many folder from subject\n\t\n\t    while (depth-- > 0) {\n\t        basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n\t        if (basePos === -1) {\n\t            return [];\n\t        }\n\t    } //consumed whole subject ?\n\t\n\t    // Get basePath match\n\t    basePos++;\n\t    end++;\n\t    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);\n\t}\n\t\n\t//\n\t// Combine two matches result and remove duplicate\n\t// (Assume sequences are sorted, matches are sorted by construction.)\n\t//\n\t\n\tfunction mergeMatches(a, b) {\n\t    var m = a.length;\n\t    var n = b.length;\n\t\n\t    if (n === 0) {\n\t        return a.slice();\n\t    }\n\t    if (m === 0) {\n\t        return b.slice();\n\t    }\n\t\n\t    var i = -1;\n\t    var j = 0;\n\t    var bj = b[j];\n\t    var out = [];\n\t\n\t    while (++i < m) {\n\t        var ai = a[i];\n\t\n\t        while (bj <= ai && ++j < n) {\n\t            if (bj < ai) {\n\t                out.push(bj);\n\t            }\n\t            bj = b[j];\n\t        }\n\t\n\t        out.push(ai);\n\t    }\n\t\n\t    while (j < n) {\n\t        out.push(b[j++]);\n\t    }\n\t\n\t    return out;\n\t}\n\t\n\t//----------------------------------------------------------------------\n\t\n\t//\n\t// Align sequence (used for fuzzaldrin.match)\n\t// Return position of subject characters that match query.\n\t//\n\t// Follow closely scorer.computeScore.\n\t// Except at each step we record what triggered the best score.\n\t// Then we trace back to output matched characters.\n\t//\n\t// Differences are:\n\t// - we record the best move at each position in a matrix, and finish by a traceback.\n\t// - we reset consecutive sequence if we do not take the match.\n\t// - no hit miss limit\n\t\n\t\n\tfunction computeMatch(subject, subject_lw, preparedQuery) {\n\t    var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\t    var query = preparedQuery.query;\n\t    var query_lw = preparedQuery.query_lw;\n\t\n\t\n\t    var m = subject.length;\n\t    var n = query.length;\n\t\n\t    //this is like the consecutive bonus, but for camelCase / snake_case initials\n\t    var acro_score = (0, _scorer.scoreAcronyms)(subject, subject_lw, query, query_lw).score;\n\t\n\t    //Init\n\t    var score_row = new Array(n);\n\t    var csc_row = new Array(n);\n\t\n\t    // Directions constants\n\t    var STOP = 0;\n\t    var UP = 1;\n\t    var LEFT = 2;\n\t    var DIAGONAL = 3;\n\t\n\t    //Traceback matrix\n\t    var trace = new Array(m * n);\n\t    var pos = -1;\n\t\n\t    //Fill with 0\n\t    var j = -1; //0..n-1\n\t    while (++j < n) {\n\t        score_row[j] = 0;\n\t        csc_row[j] = 0;\n\t    }\n\t\n\t    var move = void 0;\n\t    var score_diag = void 0;\n\t    var score = void 0;\n\t    var score_up = void 0;\n\t    var csc_diag = void 0;\n\t\n\t    var i = -1; //0..m-1\n\t    while (++i < m) {\n\t        //foreach char si of subject\n\t\n\t        score = 0;\n\t        score_up = 0;\n\t        csc_diag = 0;\n\t\n\t        var si_lw = subject_lw[i];\n\t\n\t        j = -1; //0..n-1\n\t        while (++j < n) {\n\t            //foreach char qj of query\n\t\n\t            //reset score\n\t            var csc_score = 0;\n\t            var align = 0;\n\t            score_diag = score_up;\n\t\n\t            //Compute a tentative match\n\t            if (query_lw[j] === si_lw) {\n\t\n\t                var start = (0, _scorer.isWordStart)(i, subject, subject_lw);\n\t\n\t                // Forward search for a sequence of consecutive char\n\t                csc_score = csc_diag > 0 ? csc_diag : (0, _scorer.scoreConsecutives)(subject, subject_lw, query, query_lw, i, j, start);\n\t\n\t                // Determine bonus for matching A[i] with B[j]\n\t                align = score_diag + (0, _scorer.scoreCharacter)(i, j, start, acro_score, csc_score);\n\t            }\n\t\n\t            //Prepare next sequence & match score.\n\t            score_up = score_row[j]; // Current score_up is next run score diag\n\t            csc_diag = csc_row[j];\n\t\n\t            //In case of equality, moving UP get us closer to the start of the candidate string.\n\t            if (score > score_up) {\n\t                move = LEFT;\n\t            } else {\n\t                score = score_up;\n\t                move = UP;\n\t            }\n\t\n\t            // Only take alignment if it's the absolute best option.\n\t            if (align > score) {\n\t                score = align;\n\t                move = DIAGONAL;\n\t            } else {\n\t                //If we do not take this character, break consecutive sequence.\n\t                // (when consecutive is 0, it'll be recomputed)\n\t                csc_score = 0;\n\t            }\n\t\n\t            score_row[j] = score;\n\t            csc_row[j] = csc_score;\n\t            trace[++pos] = score > 0 ? move : STOP;\n\t        }\n\t    }\n\t\n\t    // -------------------\n\t    // Go back in the trace matrix\n\t    // and collect matches (diagonals)\n\t\n\t    i = m - 1;\n\t    j = n - 1;\n\t    pos = i * n + j;\n\t    var backtrack = true;\n\t    var matches = [];\n\t\n\t    while (backtrack && i >= 0 && j >= 0) {\n\t        switch (trace[pos]) {\n\t            case UP:\n\t                i--;\n\t                pos -= n;\n\t                break;\n\t            case LEFT:\n\t                j--;\n\t                pos--;\n\t                break;\n\t            case DIAGONAL:\n\t                matches.push(i + offset);\n\t                j--;\n\t                i--;\n\t                pos -= n + 1;\n\t                break;\n\t            default:\n\t                backtrack = false;\n\t        }\n\t    }\n\t\n\t    matches.reverse();\n\t    return matches;\n\t}\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.Query = undefined;\n\t\n\tvar _pathScorer = __webpack_require__(2);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } //\n\t// Query object\n\t//\n\t// Allow to reuse some quantities computed from query.\n\t// Optional char can optionally be specified in the form of a regular expression.\n\t//\n\t\n\t\n\tvar Query = exports.Query = function Query(query) {\n\t    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t        optCharRegEx = _ref.optCharRegEx,\n\t        pathSeparator = _ref.pathSeparator;\n\t\n\t    _classCallCheck(this, Query);\n\t\n\t    if (query == null || !query.length) {\n\t        return;\n\t    }\n\t\n\t    this.query = query;\n\t    this.query_lw = query.toLowerCase();\n\t    this.core = coreChars(query, optCharRegEx);\n\t    this.core_lw = this.core.toLowerCase();\n\t    this.core_up = truncatedUpperCase(this.core);\n\t    this.depth = (0, _pathScorer.countDir)(query, query.length, pathSeparator);\n\t    this.ext = (0, _pathScorer.getExtension)(this.query_lw);\n\t    this.charCodes = getCharCodes(this.query_lw);\n\t};\n\t\n\t;\n\t\n\t//\n\t// Optional chars\n\t// Those char improve the score if present, but will not block the match (score=0) if absent.\n\t\n\tvar opt_char_re = /[ _\\-:\\/\\\\]/g;\n\t\n\tfunction coreChars(query, optCharRegEx) {\n\t\n\t    if (optCharRegEx == null) {\n\t        optCharRegEx = opt_char_re;\n\t    }\n\t\n\t    return query.replace(optCharRegEx, '');\n\t}\n\t\n\t//\n\t// Truncated Upper Case:\n\t// --------------------\n\t//\n\t// A fundamental mechanic is that we are able to keep uppercase and lowercase variant of the strings in sync.\n\t// For that we assume uppercase and lowercase version of the string have the same length. Of course unicode being unicode there's exceptions.\n\t// See ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt for the list\n\t//\n\t// \"Stra�e\".toUpperCase() -> \"STRASSE\"\n\t// truncatedUpperCase(\"Stra�e\") -> \"STRASE\"\n\t// iterating over every character, getting uppercase variant and getting first char of that.\n\t//\n\t\n\tfunction truncatedUpperCase(str) {\n\t    var upper = \"\";\n\t    for (var _iterator = str, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n\t        var _ref2;\n\t\n\t        if (_isArray) {\n\t            if (_i >= _iterator.length) break;\n\t            _ref2 = _iterator[_i++];\n\t        } else {\n\t            _i = _iterator.next();\n\t            if (_i.done) break;\n\t            _ref2 = _i.value;\n\t        }\n\t\n\t        var char = _ref2;\n\t\n\t        upper += char.toUpperCase()[0];\n\t    }\n\t    return upper;\n\t}\n\t\n\t//\n\t// Get character codes:\n\t// --------------------\n\t//\n\t// Get character codes map for a given string\n\t//\n\t\n\tfunction getCharCodes(str) {\n\t    var len = str.length;\n\t    var i = -1;\n\t\n\t    var charCodes = [];\n\t    // create map\n\t    while (++i < len) {\n\t        charCodes[str.charCodeAt(i)] = true;\n\t    }\n\t\n\t    return charCodes;\n\t}\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// fuzzaldrin-plus.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 645e73624e4b16c6ff37","//\n// Score similarity between two string\n//\n//  isMatch: Fast detection if all character of needle is in haystack\n//  score: Find string similarity using a Smith Waterman algorithm\n//         Modified to account for programing scenarios (CamelCase folder/file.ext object.property)\n//\n// Copyright (C) 2015 Jean Christophe Roy and contributors\n// MIT License: http://opensource.org/licenses/MIT\n\n\n// Base point for a single character match\n// This balance making patterns VS position and size penalty.\nconst wm = 150;\n\n//Fading function\nconst pos_bonus = 20; // The character from 0..pos_bonus receive a greater bonus for being at the start of string.\nconst tau_size = 85; // Full path length at which the whole match score is halved.\n\n// Miss count\n// When subject[i] is query[j] we register a hit.\n// Limiting hit put a boundary on how many permutation we consider to find the best one.\n// Helps to speed-up processing of long path and query containing frequent character (eg vowels)\n//\n// If a spec with frequent repetition fail, increase this.\n// This has a direct influence on worst case scenario benchmark.\nconst miss_coeff = 0.75; //Max number missed consecutive hit = ceil(miss_coeff*query.length) + 5\n\n\n//\n// Main export\n//\n\nexport default{\n\n    score,\n    isMatch,\n\n    // Other exports from the is* and score* families are available as named exports.\n    // They are used, amongst other things, to sync scorer and matcher behavior\n\n}\n\n\n// Manage the logic of testing if there's a match and calling the main scoring function\n// Also manage scoring a path and optional character.\n\nexport function score(string, query, options) {\n    let {preparedQuery, allowErrors} = options;\n    if (!allowErrors && !isMatch(string, preparedQuery.core_lw, preparedQuery.core_up)) {\n        return 0;\n    }\n    let string_lw = string.toLowerCase();\n    let score = computeScore(string, string_lw, preparedQuery);\n    return Math.ceil(score);\n}\n\n\n//\n// isMatch:\n// Are all (non optional)characters of query in subject, in proper order ?\n//\n\nexport function isMatch(subject, query_lw, query_up) {\n    let m = subject.length;\n    let n = query_lw.length;\n\n    if (!m || n > m) {\n        return false;\n    }\n\n    let i = -1;\n    let j = -1;\n\n    //foreach char of query\n    while (++j < n) {\n\n        let qj_lw = query_lw.charCodeAt(j);\n        let qj_up = query_up.charCodeAt(j);\n\n        // Continue walking the subject from where we have left with previous query char\n        // until we have found a character that is either lowercase or uppercase query.\n        while (++i < m) {\n            let si = subject.charCodeAt(i);\n            if (si === qj_lw || si === qj_up) {\n                break;\n            }\n        }\n\n        // If we passed the last char, query is not in subject\n        if (i === m) {\n            return false;\n        }\n    }\n\n    // Found every char of query in subject in proper order, match is positive\n    return true;\n}\n\n\n//----------------------------------------------------------------------\n//\n// Main scoring algorithm\n//\n\nexport function computeScore(subject, subject_lw, preparedQuery) {\n    let {query} = preparedQuery;\n    let {query_lw} = preparedQuery;\n\n    let m = subject.length;\n    let n = query.length;\n\n    let score = 0;\n\n    //----------------------------\n    // Abbreviations sequence\n\n    let acro = scoreAcronyms(subject, subject_lw, query, query_lw);\n    let acro_score = acro.score;\n\n    // Whole query is abbreviation ?\n    // => use that as score\n    if (acro.count === n) {\n        return scoreExact(n, m, acro_score, acro.pos);\n    }\n\n    //----------------------------\n    // Exact Match ?\n    // => use that as score\n\n    let pos = subject_lw.indexOf(query_lw);\n    if (pos > -1) {\n        return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);\n    }\n\n\n    //----------------------------\n    // Individual characters\n    // (Smith Waterman algorithm)\n\n\n    //Init\n    let score_row = new Array(n);\n    let csc_row = new Array(n);\n    let sz = scoreSize(n, m);\n\n    let miss_budget = Math.ceil(miss_coeff * n) + 5;\n    let miss_left = miss_budget;\n\n    //Fill with 0\n    let j = -1;\n    while (++j < n) {\n        score_row[j] = 0;\n        csc_row[j] = 0;\n    }\n\n    // Limit the search to the active region\n    // for example with query `abc`, subject `____a_bc_ac_c____`\n    // there's a region before first `a` and after last `c`\n    // that can be simplified out of the matching process\n\n    // Before first occurrence in subject of first letter of query, or -1\n    let i = subject_lw.indexOf(query_lw[0]);\n    if (i > -1) {\n        i--;\n    }\n\n    // After last occurrence of last letter of query,\n    let mm = subject_lw.lastIndexOf(query_lw[n - 1], m);\n    if (mm > i) {\n        m = mm + 1;\n    }\n\n    let csc_invalid = true;\n\n    while (++i < m) {     //foreach char si of subject\n        let si_lw = subject_lw[i];\n\n        // if si_lw is not in query\n        if (preparedQuery.charCodes[si_lw.charCodeAt(0)] == null) {\n            // reset csc_row and move to next\n            if (csc_invalid !== true) {\n                j = -1;\n                while (++j < n) {\n                    csc_row[j] = 0;\n                }\n                csc_invalid = true;\n            }\n            continue;\n        }\n\n        score = 0;\n        let score_diag = 0;\n        let csc_diag = 0;\n        let record_miss = true;\n        csc_invalid = false;\n\n        j = -1; //0..n-1\n        while (++j < n) {   //foreach char qj of query\n\n            // What is the best gap ?\n            // score_up contain the score of a gap in subject.\n            // score_left = last iteration of score, -> gap in query.\n            let score_up = score_row[j];\n            if (score_up > score) {\n                score = score_up;\n            }\n\n            //Reset consecutive\n            let csc_score = 0;\n\n            //Compute a tentative match\n            if (query_lw[j] === si_lw) {\n\n                let start = isWordStart(i, subject, subject_lw);\n\n                // Forward search for a sequence of consecutive char\n                csc_score = csc_diag > 0 ? csc_diag :\n                    scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n\n                // Determine bonus for matching A[i] with B[j]\n                let align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n\n                //Are we better using this match or taking the best gap (currently stored in score)?\n                if (align > score) {\n                    score = align;\n                    // reset consecutive missed hit count\n                    miss_left = miss_budget;\n                } else {\n                    // We rejected this match and record a miss.\n                    // If budget is exhausted exit\n                    if (record_miss && --miss_left <= 0) {\n                        return score_row[n - 1] * sz;\n                    }\n                    record_miss = false;\n                }\n            }\n\n\n            //Prepare next sequence & match score.\n            score_diag = score_up;\n            csc_diag = csc_row[j];\n            csc_row[j] = csc_score;\n            score_row[j] = score;\n        }\n    }\n\n    // get highest score so far\n    score = score_row[n - 1];\n    return score * sz;\n\n}\n\n//\n// Boundaries\n//\n// Is the character at the start of a word, end of the word, or a separator ?\n// Fortunately those small function inline well.\n//\n\nexport function isWordStart(pos, subject, subject_lw) {\n    if (pos === 0) {\n        return true;\n    } // match is FIRST char ( place a virtual token separator before first char of string)\n    let curr_s = subject[pos];\n    let prev_s = subject[pos - 1];\n    return isSeparator(prev_s) || // match FOLLOW a separator\n        (  curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1] ); // match is Capital in camelCase (preceded by lowercase)\n}\n\n\nexport function isWordEnd(pos, subject, subject_lw, len) {\n    if (pos === len - 1) {\n        return true;\n    } // last char of string\n    let curr_s = subject[pos];\n    let next_s = subject[pos + 1];\n    return isSeparator(next_s) || // match IS FOLLOWED BY a separator\n        ( curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1] ); // match is lowercase, followed by uppercase\n}\n\nexport function isSeparator(c) {\n    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\\\';\n}\n//\n// Scoring helper\n//\n\nexport function scorePosition(pos) {\n    if (pos < pos_bonus) {\n        let sc = pos_bonus - pos;\n        return 100 + (sc * sc);\n    } else {\n        return Math.max((100 + pos_bonus) - pos, 0);\n    }\n}\n\nexport function scoreSize(n, m) {\n    // Size penalty, use the difference of size (m-n)\n    return tau_size / ( tau_size + Math.abs(m - n))\n}\n\nexport function scoreExact(n, m, quality, pos) {\n    return 2 * n * ( (wm * quality) + scorePosition(pos) ) * scoreSize(n, m);\n}\n\n\n//\n// Shared scoring logic between exact match, consecutive & acronym\n// Ensure pattern length dominate the score then refine to take into account case-sensitivity\n// and structural quality of the pattern on the overall string (word boundary)\n//\n\nexport function scorePattern(count, len, sameCase, start, end) {\n    let sz = count;\n\n    let bonus = 6; // to ensure consecutive length dominate score, this should be as large other bonus combined\n    if (sameCase === count) {\n        bonus += 2;\n    }\n    if (start) {\n        bonus += 3;\n    }\n    if (end) {\n        bonus += 1;\n    }\n\n    if (count === len) {\n        // when we match 100% of query we allow to break the size ordering.\n        // This is to help exact match bubble up vs size, depth penalty etc\n        if (start) {\n            if (sameCase === len) {\n                sz += 2;\n            } else {\n                sz += 1;\n            }\n        }\n        if (end) {\n            bonus += 1;\n        }\n    }\n\n    return sameCase + (sz * ( sz + bonus ));\n}\n\n\n//\n// Compute the bonuses for two chars that are confirmed to matches in a case-insensitive way\n//\n\nexport function scoreCharacter(i, j, start, acro_score, csc_score) {\n\n    // start of string / position of match bonus\n    let posBonus = scorePosition(i);\n\n    // match IS a word boundary\n    // choose between taking part of consecutive characters or consecutive acronym\n    if (start) {\n        return posBonus + (wm * ( (acro_score > csc_score ? acro_score : csc_score) + 10  ));\n    }\n\n    // normal Match\n    return posBonus + (wm * csc_score);\n}\n\n\n//\n// Forward search for a sequence of consecutive character.\n//\n\nexport function scoreConsecutives(subject, subject_lw, query, query_lw, i, j, startOfWord) {\n    let m = subject.length;\n    let n = query.length;\n\n    let mi = m - i;\n    let nj = n - j;\n    let k = mi < nj ? mi : nj;\n\n    let sameCase = 0;\n    let sz = 0; //sz will be one more than the last qi is sj\n\n    // query_lw[i] is subject_lw[j] has been checked before entering now do case sensitive check.\n    if (query[j] === subject[i]) {\n        sameCase++;\n    }\n\n    //Continue while lowercase char are the same, record when they are case-sensitive match.\n    while (++sz < k && query_lw[++j] === subject_lw[++i]) {\n        if (query[j] === subject[i]) {\n            sameCase++;\n        }\n    }\n\n    // Faster path for single match.\n    // Isolated character match occurs often and are not really interesting.\n    // Fast path so we don't compute expensive pattern score on them.\n    // Acronym should be addressed with acronym context bonus instead of consecutive.\n    if (sz === 1) {\n        return 1 + (2 * sameCase);\n    }\n\n    return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));\n}\n\n\n//\n// Compute the score of an exact match at position pos.\n//\n\nexport function scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m) {\n\n    // Test for word start\n    let start = isWordStart(pos, subject, subject_lw);\n\n    // Heuristic\n    // If not a word start, test next occurrence\n    // - We want exact match to be fast\n    // - For exact match, word start has the biggest impact on score.\n    // - Testing 2 instances is somewhere between testing only one and testing every instances.\n\n    if (!start) {\n        let pos2 = subject_lw.indexOf(query_lw, pos + 1);\n        if (pos2 > -1) {\n            start = isWordStart(pos2, subject, subject_lw);\n            if (start) {\n                pos = pos2;\n            }\n        }\n    }\n\n    //Exact case bonus.\n    let i = -1;\n    let sameCase = 0;\n    while (++i < n) {\n        if (query[pos + i] === subject[i]) {\n            sameCase++;\n        }\n    }\n\n    let end = isWordEnd((pos + n) - 1, subject, subject_lw, m);\n\n    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);\n}\n\n\n//\n// Acronym prefix\n//\n\n\nclass AcronymResult {\n    constructor(score, pos, count) {\n        this.score = score;\n        this.pos = pos;\n        this.count = count;\n    }\n}\n\nlet emptyAcronymResult = new AcronymResult(0, 0.1, 0);\n\nexport function scoreAcronyms(subject, subject_lw, query, query_lw) {\n    let m = subject.length;\n    let n = query.length;\n\n    //a single char is not an acronym\n    if (m <= 1 || n <= 1) {\n        return emptyAcronymResult;\n    }\n\n    let count = 0;\n    let sepCount = 0;\n    let sumPos = 0;\n    let sameCase = 0;\n\n    let i = -1;\n    let j = -1;\n\n    //foreach char of query\n    while (++j < n) {\n\n        let qj_lw = query_lw[j];\n\n        // Separator will not score point but will continue the prefix when present.\n        // Test that the separator is in the candidate and advance cursor to that position.\n        // If no separator break the prefix\n\n        if (isSeparator(qj_lw)) {\n            i = subject_lw.indexOf(qj_lw, i + 1);\n            if (i > -1) {\n                sepCount++;\n                continue;\n            } else {\n                break;\n            }\n        }\n\n        // For other characters we search for the first match where subject[i] = query[j]\n        // that also happens to be a start-of-word\n\n        while (++i < m) {\n            if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {\n                if (query[j] === subject[i]) {\n                    sameCase++;\n                }\n                sumPos += i;\n                count++;\n                break;\n            }\n        }\n\n        // All of subject is consumed, stop processing the query.\n        if (i === m) {\n            break;\n        }\n    }\n\n\n    // Here, all of query is consumed (or we have reached a character not in acronym)\n    // A single character is not an acronym (also prevent division by 0)\n    if (count < 2) {\n        return emptyAcronymResult;\n    }\n\n    // Acronym are scored as start-of-word\n    // Unless the acronym is a 1:1 match with candidate then it is upgraded to full-word.\n    let fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;\n    let score = scorePattern(count, n, sameCase, true, fullWord);\n\n    return new AcronymResult(score, sumPos / count, count + sepCount);\n}\n\n\n//\n// Test whether there's a 1:1 relationship between query and acronym of candidate.\n// For that to happens\n// (a) All character of query must be matched to an acronym of candidate\n// (b) All acronym of candidate must be matched to a character of query.\n//\n// This method check for (b) assuming (a) has been checked before entering.\n\nfunction isAcronymFullWord(subject, subject_lw, query, nbAcronymInQuery) {\n    let m = subject.length;\n    let n = query.length;\n    let count = 0;\n\n    // Heuristic:\n    // Assume one acronym every (at most) 12 character on average\n    // This filter out long paths, but then they can match on the filename.\n    if (m > 12 * n) {\n        return false;\n    }\n\n    let i = -1;\n    while (++i < m) {\n        //For each char of subject\n        //Test if we have an acronym, if so increase acronym count.\n        //If the acronym count is more than nbAcronymInQuery (number of non separator char in query)\n        //Then we do not have 1:1 relationship.\n        if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/scorer.js","import {isMatch, computeScore, scoreSize} from \"./scorer\";\r\n\r\n\r\nconst tau_depth = 13; //  Directory depth at which the full path influence is halved.\r\nconst file_coeff = 1.2; //  Full path is also penalized for length of basename. This adjust a scale factor for that penalty.\r\n\r\nexport default{\r\n    score,\r\n    countDir,\r\n    getExtensionScore\r\n}\r\n\r\n//  Manage the logic of testing if there's a match and calling the main scoring function\r\n//  Also manage scoring a path and optional character.\r\n\r\nexport function score(string, query, options) {\r\n    let {preparedQuery, allowErrors} = options;\r\n    if (!allowErrors && !isMatch(string, preparedQuery.core_lw, preparedQuery.core_up)) {\r\n        return 0;\r\n    }\r\n    let string_lw = string.toLowerCase();\r\n    let score = computeScore(string, string_lw, preparedQuery);\r\n    score = scorePath(string, string_lw, score, options);\r\n    return Math.ceil(score);\r\n}\r\n\r\n\r\n// \r\n//  Score adjustment for path\r\n// \r\n\r\nfunction scorePath(subject, subject_lw, fullPathScore, options) {\r\n\r\n    if (fullPathScore === 0) {\r\n        return 0;\r\n    }\r\n\r\n    let {preparedQuery, useExtensionBonus, pathSeparator} = options;\r\n\r\n    //  Skip trailing slashes\r\n    let end = subject.length - 1;\r\n    while (subject[end] === pathSeparator) {\r\n        end--;\r\n    }\r\n\r\n    //  Get position of basePath of subject.\r\n    let basePos = subject.lastIndexOf(pathSeparator, end);\r\n    let fileLength = end - basePos;\r\n\r\n    //  Get a bonus for matching extension\r\n    let extAdjust = 1.0;\r\n\r\n    if (useExtensionBonus) {\r\n        extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);\r\n        fullPathScore *= extAdjust;\r\n    }\r\n\r\n    //  no basePath, nothing else to compute.\r\n    if (basePos === -1) {\r\n        return fullPathScore;\r\n    }\r\n\r\n    //  Get the number of folder in query\r\n    let {depth} = preparedQuery;\r\n\r\n    //  Get that many folder from subject\r\n    while (basePos > -1 && depth-- > 0) {\r\n        basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\r\n    }\r\n\r\n    //  Get basePath score, if BaseName is the whole string, no need to recompute\r\n    //  We still need to apply the folder depth and filename penalty.\r\n    let basePathScore = (basePos === -1) ? fullPathScore :\r\n    extAdjust * computeScore(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery);\r\n\r\n    //  Final score is linear interpolation between base score and full path score.\r\n    //  For low directory depth, interpolation favor base Path then include more of full path as depth increase\r\n    //\r\n    //  A penalty based on the size of the basePath is applied to fullPathScore\r\n    //  That way, more focused basePath match can overcome longer directory path.\r\n\r\n    let alpha = (0.5 * tau_depth) / ( tau_depth + countDir(subject, end + 1, pathSeparator) );\r\n    return (alpha * basePathScore) + ((1 - alpha) * fullPathScore * scoreSize(0, file_coeff * (fileLength)));\r\n}\r\n\r\n\r\n// \r\n//  Count number of folder in a path.\r\n//  (consecutive slashes count as a single directory)\r\n// \r\n\r\nexport function countDir(path, end, pathSeparator) {\r\n    if (end < 1) {\r\n        return 0;\r\n    }\r\n\r\n    let count = 0;\r\n    let i = -1;\r\n\r\n    // skip slash at the start so `foo/bar` and `/foo/bar` have the same depth.\r\n    while (++i < end && path[i] === pathSeparator) {\r\n    }\r\n\r\n    while (++i < end) {\r\n        if (path[i] === pathSeparator) {\r\n            count++; // record first slash, but then skip consecutive ones\r\n            while (++i < end && path[i] === pathSeparator) {\r\n            }\r\n        }\r\n    }\r\n\r\n    return count;\r\n}\r\n\r\n// \r\n//  Find fraction of extension that is matched by query.\r\n//  For example mf.h prefers myFile.h to myfile.html\r\n//  This need special handling because it give point for not having characters (the `tml` in above example)\r\n// \r\n\r\nexport function getExtension(str) {\r\n    let pos = str.lastIndexOf(\".\");\r\n    if (pos < 0) {\r\n        return \"\";\r\n    } else {\r\n        return str.substr(pos + 1);\r\n    }\r\n}\r\n\r\n\r\nexport function getExtensionScore(candidate, ext, startPos, endPos, maxDepth) {\r\n    //  startPos is the position of last slash of candidate, -1 if absent.\r\n\r\n    if (ext == null || !ext.length) {\r\n        return 0;\r\n    }\r\n\r\n    //  Check that (a) extension exist, (b) it is after the start of the basename\r\n    let pos = candidate.lastIndexOf(\".\", endPos);\r\n    if (pos <= startPos) {\r\n        return 0;\r\n    } //  (note that startPos >= -1)\r\n\r\n    let n = ext.length;\r\n    let m = endPos - pos;\r\n\r\n    //  n contain the smallest of both extension length, m the largest.\r\n    if (m < n) {\r\n        n = m;\r\n        m = ext.length;\r\n    }\r\n\r\n    // place cursor after dot & count number of matching characters in extension\r\n    pos++;\r\n    let matched = -1;\r\n    while (++matched < n) {\r\n        if (candidate[pos + matched] !== ext[matched]) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    //  if nothing found, try deeper for multiple extensions, with some penalty for depth\r\n    if (matched === 0 && maxDepth > 0) {\r\n        return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);\r\n    }\r\n\r\n    //  cannot divide by zero because m is the largest extension length and we return if either is 0\r\n    return matched / m;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/pathScorer.js","import {filter as processFilter} from \"./lib/filter\";\r\nimport {score as processScore} from \"./lib/scorer\";\r\nimport  {score as processPathScore} from \"./lib/pathScorer\";\r\nimport {match as processMatch, wrap as processWrap} from \"./lib/matcher\";\r\nimport {Query} from \"./lib/query\";\r\n\r\nconst fuzzaldrin = {\r\n    filter,\r\n    score,\r\n    match,\r\n    wrap,\r\n    prepareQuery,\r\n};\r\n\r\nexport default fuzzaldrin\r\n\r\nlet preparedQueryCache = null;\r\n\r\n/**\r\n * Filter:\r\n *  Given a list of candidate, output a list of candidate that match query.\r\n *  Output list is the same format (string or object) than input list.\r\n *\r\n *  If given a list of object, specify options.key as the property `candidate[key]`\r\n *  that contain the string representation of the candidate\r\n *\r\n *  Output is sorted by match score.\r\n *\r\n * @param {Array.<(string|object)>} candidates - array of string or objects\r\n * @param {string} query - string to search for in each candidate\r\n * @param {FilterOptions=} options - (optional) see option hash doc\r\n * @returns {Array.<(string|object)>} - filtered & sorted subset of input candidates\r\n */\r\n\r\nexport function filter(candidates, query, options) {\r\n\r\n    if (query == null || !query.length) return [];\r\n    if (candidates == null || !candidates.length) return [];\r\n    options = parseOptions(options, query);\r\n    return processFilter(candidates, query, options);\r\n\r\n}\r\n\r\n/**\r\n * Score:\r\n *   Give the numerical score on how a given string match query.\r\n *\r\n *   This is provided so you can build your own filter method.\r\n *   For example you may have a special way to iterate candidate,\r\n *   access candidate string representation, or you may need to\r\n *   modify the score to account external knowledge (eg last modified date)\r\n *\r\n * @param {string} string - string representation of a candidate\r\n * @param {string} query - string to search for in candidate\r\n * @param {ScoringOptions=} options - (optional) see option hash doc\r\n * @returns {number} score 0 .. max, where max is score(string, string)\r\n */\r\n\r\nexport function score(string, query, options) {\r\n\r\n    if (string == null || !string.length) return 0;\r\n    if (query == null || !query.length) return 0;\r\n\r\n    options = parseOptions(options, query);\r\n\r\n    if (options.usePathScoring) {\r\n        return processPathScore(string, query, options);\r\n    } else {\r\n        return processScore(string, query, options);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Match:\r\n *    Communicate which characters of candidate where selected by the algorithm to represent the query.\r\n *    The match function output an array of character position.\r\n *    If you need to display those character as an html string see wrap function.\r\n *\r\n * @param {string} string - string representation of a candidate\r\n * @param {string} query - string to search for in candidate\r\n * @param {MatchOptions=} options (optional)\r\n * @returns {Array.<number>}\r\n */\r\n\r\nexport function match(string, query, options) {\r\n\r\n    if (string == null || !string.length) return [];\r\n    if (query == null || !query.length) return [];\r\n\r\n    //If both are the same, return an array of consecutive numbers\r\n    if (string === query) {\r\n        let length = string.length;\r\n        let range = new Array(length);\r\n        for (let idx = 0; idx < length; idx++) {\r\n            range[idx] = idx;\r\n        }\r\n        return range;\r\n    }\r\n\r\n    options = parseOptions(options, query);\r\n    return processMatch(string, query, options);\r\n}\r\n\r\n\r\n/**\r\n * Wrap:\r\n *    Communicate which characters of candidate where selected by the algorithm to represent the query.\r\n *    This function output the given string with chosen character wrapped in a delimiter string (eg html tag).\r\n *\r\n *    To control the wrap use the option hash.\r\n *    Here are some default value:\r\n *      options.tagOpen = `<strong class=\"highlight\">`\r\n *      options.tagClose = `</strong>`\r\n *\r\n *    Alternatively, if you chose to keep the default tagOpen,\r\n *    you can specify option.tagClass and change the `highlight`\r\n *    class to one of your choosing.\r\n *\r\n *    Wrap method will try to group consecutive matches under the same tag.\r\n *\r\n * @param {string} string - string representation of a candidate\r\n * @param {string} query - string to search for in candidate\r\n * @param {WrapOptions=} options\r\n * @returns {string} - input string with match wrapped in open and close tag.\r\n */\r\n\r\nexport function wrap(string, query, options) {\r\n\r\n    if (string == null || !string.length) return \"\";\r\n    if (query == null || !query.length) return \"\";\r\n\r\n    options = parseOptions(options, query);\r\n    return processWrap(string, query, options);\r\n\r\n}\r\n\r\n/**\r\n * PrepareQuery:\r\n *   The usual scenario is to compare a single query with multiple candidate.\r\n *   To speed that process up, we pre-compute some information about the query.\r\n *\r\n *   Pre-computed query is natural to use in bulk method like filter, but harder\r\n *   in one-by-one method like score or match. To keep those method fast you can give\r\n *   a pre computed query in option hash as `options.preparedQuery`\r\n *\r\n *   Note that we use an internal cache `preparedQueryCache` that cover most of the simple cases\r\n *   So this method may not be needed in thos cases.\r\n *\r\n * @param {string} query\r\n * @param {QueryOptions} options\r\n * @returns {Query}\r\n */\r\n\r\nexport function prepareQuery(query, options) {\r\n    options = parseOptions(options, query);\r\n    return options.preparedQuery;\r\n}\r\n\r\n\r\n//\r\n// Detect node.js or browser to set default path separator\r\n//\r\n\r\nlet defaultPathSeparator = \"/\";\r\n\r\nif (typeof process === 'object' && Object.prototype.toString.call(process) === '[object process]') {\r\n\r\n    // On node js we assume the list of candidates match local OS path format.\r\n    // See comment bellow to change behavior.\r\n    defaultPathSeparator = (process.platform === \"win32\") ? '\\\\' : '/';\r\n\r\n} else if (typeof window === 'object' && Object.prototype.toString.call(window) === \"[object Window]\") {\r\n\r\n    // We assume that browser are dealing with url, if assumption is false use option hash like so:\r\n    // fuzzaldrin.filter( candidates, query, {pathSeparator: platformSep} )\r\n    // and determine `platformSep` any so it match the format of candidates.\r\n\r\n    defaultPathSeparator = \"/\";\r\n\r\n    // Export main object to global window.\r\n    window.fuzzaldrin = fuzzaldrin;\r\n\r\n}\r\n\r\n//\r\n// Setup default values\r\n//\r\n\r\n/**\r\n * @type {ScoringOptions}\r\n */\r\nlet defaultOptions = {\r\n    allowErrors: false,\r\n    usePathScoring: true,\r\n    useExtensionBonus: false,\r\n    pathSeparator: defaultPathSeparator,\r\n    optCharRegEx: null,\r\n    preparedQuery: null,\r\n};\r\n\r\n/**\r\n *\r\n * @param {(ScoringOptions|FilterOptions|MatchOptions|WrapOptions)} options\r\n * @param {string} query\r\n * @returns {(ScoringOptions|FilterOptions|MatchOptions|WrapOptions)} options completed with default values from ScoringOptions\r\n */\r\nfunction parseOptions(options, query) {\r\n\r\n    // If no options given, copy default\r\n    // Else merge options with defaults.\r\n\r\n    if(options == null) options = {};\r\n\r\n    let hasOwnProperty = Object.prototype.hasOwnProperty;\r\n    for(let key in defaultOptions){\r\n        if(hasOwnProperty.call(defaultOptions,key) && !hasOwnProperty.call(options,key) ){\r\n            options[key] = defaultOptions[key];\r\n        }\r\n    }\r\n\r\n    // if preparedQuery is given use it\r\n    // else assign from cache, recompute cache if needed\r\n    if (options.preparedQuery == null) {\r\n\r\n        if (preparedQueryCache == null || preparedQueryCache.query !== query) {\r\n            preparedQueryCache = new Query(query, options)\r\n        }\r\n        options.preparedQuery = preparedQueryCache;\r\n    }\r\n\r\n    return options;\r\n}\r\n\r\n\r\n//\r\n// Documentation for option hash\r\n//\r\n\r\n/**\r\n * @typedef {Object} QueryOptions\r\n * @property {string} pathSeparator - If candidate are path, indicate path seperator used.\r\n * @property {RegExp} optCharRegEx - Some characters do not have to match exactly, example `space`.\r\n *\r\n */\r\n\r\n/**\r\n * @typedef {Object} ScoringOptions\r\n * @extends QueryOptions\r\n *\r\n * @property {boolean} allowErrors - Should we allow candidates that does not have all characters of query ?\r\n * @property {boolean} usePathScoring - Should we try to interpret candidates as path\r\n * @property {boolean} useExtensionBonus - Should we try to interpret extension from query\r\n *                                         and prefer files that match that extension (needs usePathScoring)\r\n * @property {Query} preparedQuery - If you have a precomputed query object set it here.\r\n */\r\n\r\n\r\n/**\r\n * @typedef {Object} FilterOptions\r\n * @extends ScoringOptions\r\n *\r\n * @property {string} key - Object are given, this is the key of object that contain the string to be scored.\r\n * @property {number} maxResults - Output the top `maxResults` best results at most.\r\n * @property {number} maxInners - Speed vs correctness optimisation: stop filtering after that many positive results\r\n */\r\n\r\n/**\r\n * @typedef {Object} MatchOptions\r\n * @extends ScoringOptions\r\n *\r\n *\r\n */\r\n\r\n/**\r\n * @typedef {Object} WrapOptions\r\n * @extends MatchOptions\r\n *\r\n * @property {string} tagOpen - string to place before a match default to `<strong class=\"highlight\">`\r\n * @property {string} tagClose - string to place after a match default to `</strong>`\r\n * @property {string} tagClass - change the class of the default open tag (tagOpen must be unset)\r\n *\r\n */\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/fuzzaldrin-plus.js","import scorer from \"./scorer\";\r\nimport pathScorer from \"./pathScorer\";\r\n\r\nexport default {\r\n    filter\r\n};\r\n\r\nexport function filter(candidates, query, options) {\r\n    let scoredCandidates = [];\r\n\r\n    // See also option parsing on main module for default\r\n    let {key, maxResults, maxInners, usePathScoring} = options;\r\n    let spotLeft = (maxInners != null) && maxInners > 0 ? maxInners : candidates.length + 1;\r\n    let bKey = (key != null);\r\n    let scoreProvider = usePathScoring ? pathScorer : scorer;\r\n\r\n    for (let candidate of candidates) {\r\n\r\n        // Get the candidate value\r\n        let string = bKey ? candidate[key] : candidate;\r\n        if (string == null || !string.length) {\r\n            continue;\r\n        }\r\n\r\n        // Get score, If score greater than 0 add to valid results\r\n        let score = scoreProvider.score(string, query, options);\r\n        if (score > 0) {\r\n            scoredCandidates.push({candidate, score});\r\n            spotLeft -= 1;\r\n            if (spotLeft <= 0) {\r\n                break;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    //  Sort scores in descending order\r\n    scoredCandidates.sort(sortCandidates);\r\n\r\n    // Extract original candidate\r\n    let validCandidates = scoredCandidates.map(pluckCandidates);\r\n\r\n    // Trim to maxResults if specified\r\n    if (maxResults != null) {\r\n        validCandidates = candidates.slice(0, maxResults);\r\n    }\r\n\r\n    // And return\r\n    return validCandidates;\r\n}\r\n\r\nfunction pluckCandidates(a) {\r\n    return a.candidate;\r\n}\r\nfunction sortCandidates(a, b) {\r\n    return b.score - a.score;\r\n}\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/filter.js","// A match list is an array of indexes to characters that match.\r\n// This file should closely follow `scorer` except that it returns an array\r\n// of indexes instead of a score.\r\nimport {isMatch, isWordStart, scoreConsecutives, scoreCharacter, scoreAcronyms} from \"./scorer\";\r\n\r\n\r\nexport default{\r\n    match,\r\n    wrap,\r\n}\r\n\r\n\r\n// Return position of character which matches\r\n\r\nexport function match(string, query, options) {\r\n\r\n    let {allowErrors, preparedQuery, pathSeparator} = options;\r\n\r\n    if (!allowErrors && !isMatch(string, preparedQuery.core_lw, preparedQuery.core_up)) {\r\n        return [];\r\n    }\r\n    let string_lw = string.toLowerCase();\r\n\r\n    // Full path results\r\n    let matches = computeMatch(string, string_lw, preparedQuery);\r\n\r\n    //if there is no matches on the full path, there should not be any on the base path either.\r\n    if (matches.length === 0) {\r\n        return matches;\r\n    }\r\n\r\n    // Is there a base path ?\r\n    if (string.indexOf(pathSeparator) > -1) {\r\n\r\n        // Base path results\r\n        let baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);\r\n\r\n        // Combine the results, removing duplicate indexes\r\n        matches = mergeMatches(matches, baseMatches);\r\n    }\r\n\r\n    return matches;\r\n}\r\n\r\n\r\n//\r\n// Wrap\r\n//\r\n// Helper around match if you want a string with result wrapped by some delimiter text\r\n\r\nexport function wrap(string, query, options) {\r\n\r\n    let tagClass = options.tagClass ||  'highlight';\r\n    let tagOpen = options.tagOpen || `<strong class=\"${tagClass}\">`;\r\n    let tagClose = options.tagClose || '</strong>';\r\n\r\n    if (string === query) {\r\n        return tagOpen + string + tagClose;\r\n    }\r\n\r\n    //Run get position where a match is found\r\n    let matchPositions = match(string, query, options);\r\n\r\n    //If no match return as is\r\n    if (matchPositions.length === 0) {\r\n        return string;\r\n    }\r\n\r\n    //Loop over match positions\r\n    let output = '';\r\n    let matchIndex = -1;\r\n    let strPos = 0;\r\n    while (++matchIndex < matchPositions.length) {\r\n        let matchPos = matchPositions[matchIndex];\r\n\r\n        // Get text before the current match position\r\n        if (matchPos > strPos) {\r\n            output += string.substring(strPos, matchPos);\r\n            strPos = matchPos;\r\n        }\r\n\r\n        // Get consecutive matches to wrap under a single tag\r\n        while (++matchIndex < matchPositions.length) {\r\n            if (matchPositions[matchIndex] === matchPos + 1) {\r\n                matchPos++;\r\n            } else {\r\n                matchIndex--;\r\n                break;\r\n            }\r\n        }\r\n\r\n        //Get text inside the match, including current character\r\n        matchPos++;\r\n        if (matchPos > strPos) {\r\n            output += tagOpen;\r\n            output += string.substring(strPos, matchPos);\r\n            output += tagClose;\r\n            strPos = matchPos;\r\n        }\r\n    }\r\n\r\n    //Get string after last match\r\n    if (strPos < string.length - 1) {\r\n        output += string.substring(strPos);\r\n    }\r\n\r\n    //return wrapped text\r\n    return output;\r\n}\r\n\r\n\r\nfunction basenameMatch(subject, subject_lw, preparedQuery, pathSeparator) {\r\n\r\n    // Skip trailing slashes\r\n    let end = subject.length - 1;\r\n    while (subject[end] === pathSeparator) {\r\n        end--;\r\n    }\r\n\r\n    // Get position of basePath of subject.\r\n    let basePos = subject.lastIndexOf(pathSeparator, end);\r\n\r\n    //If no PathSeparator, no base path exist.\r\n    if (basePos === -1) {\r\n        return [];\r\n    }\r\n\r\n    // Get the number of folder in query\r\n    let {depth} = preparedQuery;\r\n\r\n    // Get that many folder from subject\r\n    while (depth-- > 0) {\r\n        basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\r\n        if (basePos === -1) {\r\n            return [];\r\n        }\r\n    } //consumed whole subject ?\r\n\r\n    // Get basePath match\r\n    basePos++;\r\n    end++;\r\n    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);\r\n}\r\n\r\n\r\n//\r\n// Combine two matches result and remove duplicate\r\n// (Assume sequences are sorted, matches are sorted by construction.)\r\n//\r\n\r\nfunction mergeMatches(a, b) {\r\n    let m = a.length;\r\n    let n = b.length;\r\n\r\n    if (n === 0) {\r\n        return a.slice();\r\n    }\r\n    if (m === 0) {\r\n        return b.slice();\r\n    }\r\n\r\n    let i = -1;\r\n    let j = 0;\r\n    let bj = b[j];\r\n    let out = [];\r\n\r\n    while (++i < m) {\r\n        let ai = a[i];\r\n\r\n        while (bj <= ai && ++j < n) {\r\n            if (bj < ai) {\r\n                out.push(bj);\r\n            }\r\n            bj = b[j];\r\n        }\r\n\r\n        out.push(ai);\r\n    }\r\n\r\n    while (j < n) {\r\n        out.push(b[j++]);\r\n    }\r\n\r\n    return out;\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n\r\n//\r\n// Align sequence (used for fuzzaldrin.match)\r\n// Return position of subject characters that match query.\r\n//\r\n// Follow closely scorer.computeScore.\r\n// Except at each step we record what triggered the best score.\r\n// Then we trace back to output matched characters.\r\n//\r\n// Differences are:\r\n// - we record the best move at each position in a matrix, and finish by a traceback.\r\n// - we reset consecutive sequence if we do not take the match.\r\n// - no hit miss limit\r\n\r\n\r\nfunction computeMatch(subject, subject_lw, preparedQuery, offset = 0) {\r\n    let {query} = preparedQuery;\r\n    let {query_lw} = preparedQuery;\r\n\r\n    let m = subject.length;\r\n    let n = query.length;\r\n\r\n    //this is like the consecutive bonus, but for camelCase / snake_case initials\r\n    let acro_score = scoreAcronyms(subject, subject_lw, query, query_lw).score;\r\n\r\n    //Init\r\n    let score_row = new Array(n);\r\n    let csc_row = new Array(n);\r\n\r\n    // Directions constants\r\n    let STOP = 0;\r\n    let UP = 1;\r\n    let LEFT = 2;\r\n    let DIAGONAL = 3;\r\n\r\n    //Traceback matrix\r\n    let trace = new Array(m * n);\r\n    let pos = -1;\r\n\r\n    //Fill with 0\r\n    let j = -1; //0..n-1\r\n    while (++j < n) {\r\n        score_row[j] = 0;\r\n        csc_row[j] = 0;\r\n    }\r\n\r\n    let move;\r\n    let score_diag;\r\n    let score;\r\n    let score_up;\r\n    let csc_diag;\r\n\r\n    let i = -1; //0..m-1\r\n    while (++i < m) { //foreach char si of subject\r\n\r\n        score = 0;\r\n        score_up = 0;\r\n        csc_diag = 0;\r\n\r\n        let si_lw = subject_lw[i];\r\n\r\n        j = -1; //0..n-1\r\n        while (++j < n) { //foreach char qj of query\r\n\r\n            //reset score\r\n            let csc_score = 0;\r\n            let align = 0;\r\n            score_diag = score_up;\r\n\r\n            //Compute a tentative match\r\n            if (query_lw[j] === si_lw) {\r\n\r\n                let start = isWordStart(i, subject, subject_lw);\r\n\r\n                // Forward search for a sequence of consecutive char\r\n                csc_score = csc_diag > 0 ? csc_diag :\r\n                    scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\r\n\r\n                // Determine bonus for matching A[i] with B[j]\r\n                align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\r\n            }\r\n\r\n            //Prepare next sequence & match score.\r\n            score_up = score_row[j]; // Current score_up is next run score diag\r\n            csc_diag = csc_row[j];\r\n\r\n            //In case of equality, moving UP get us closer to the start of the candidate string.\r\n            if (score > score_up) {\r\n                move = LEFT;\r\n            } else {\r\n                score = score_up;\r\n                move = UP;\r\n            }\r\n\r\n            // Only take alignment if it's the absolute best option.\r\n            if (align > score) {\r\n                score = align;\r\n                move = DIAGONAL;\r\n            } else {\r\n                //If we do not take this character, break consecutive sequence.\r\n                // (when consecutive is 0, it'll be recomputed)\r\n                csc_score = 0;\r\n            }\r\n\r\n            score_row[j] = score;\r\n            csc_row[j] = csc_score;\r\n            trace[++pos] = (score > 0) ? move : STOP;\r\n        }\r\n    }\r\n\r\n    // -------------------\r\n    // Go back in the trace matrix\r\n    // and collect matches (diagonals)\r\n\r\n    i = m - 1;\r\n    j = n - 1;\r\n    pos = (i * n) + j;\r\n    let backtrack = true;\r\n    let matches = [];\r\n\r\n    while (backtrack && i >= 0 && j >= 0) {\r\n        switch (trace[pos]) {\r\n            case UP:\r\n                i--;\r\n                pos -= n;\r\n                break;\r\n            case LEFT:\r\n                j--;\r\n                pos--;\r\n                break;\r\n            case DIAGONAL:\r\n                matches.push(i + offset);\r\n                j--;\r\n                i--;\r\n                pos -= n + 1;\r\n                break;\r\n            default:\r\n                backtrack = false;\r\n        }\r\n    }\r\n\r\n    matches.reverse();\r\n    return matches;\r\n}\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/matcher.js","//\r\n// Query object\r\n//\r\n// Allow to reuse some quantities computed from query.\r\n// Optional char can optionally be specified in the form of a regular expression.\r\n//\r\nimport {countDir, getExtension} from \"./pathScorer\";\r\n\r\nexport class Query {\r\n\r\n    constructor(query, {optCharRegEx, pathSeparator} = {}) {\r\n\r\n        if (query == null || !query.length) {\r\n            return;\r\n        }\r\n\r\n        this.query = query;\r\n        this.query_lw = query.toLowerCase();\r\n        this.core = coreChars(query, optCharRegEx);\r\n        this.core_lw = this.core.toLowerCase();\r\n        this.core_up = truncatedUpperCase(this.core);\r\n        this.depth = countDir(query, query.length, pathSeparator);\r\n        this.ext = getExtension(this.query_lw);\r\n        this.charCodes = getCharCodes(this.query_lw);\r\n    }\r\n};\r\n\r\n\r\n//\r\n// Optional chars\r\n// Those char improve the score if present, but will not block the match (score=0) if absent.\r\n\r\nconst opt_char_re = /[ _\\-:\\/\\\\]/g;\r\n\r\nfunction coreChars(query, optCharRegEx) {\r\n\r\n    if (optCharRegEx == null) {\r\n        optCharRegEx = opt_char_re\r\n    }\r\n\r\n    return query.replace(optCharRegEx, '');\r\n}\r\n\r\n//\r\n// Truncated Upper Case:\r\n// --------------------\r\n//\r\n// A fundamental mechanic is that we are able to keep uppercase and lowercase variant of the strings in sync.\r\n// For that we assume uppercase and lowercase version of the string have the same length. Of course unicode being unicode there's exceptions.\r\n// See ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt for the list\r\n//\r\n// \"Stra�e\".toUpperCase() -> \"STRASSE\"\r\n// truncatedUpperCase(\"Stra�e\") -> \"STRASE\"\r\n// iterating over every character, getting uppercase variant and getting first char of that.\r\n//\r\n\r\nfunction truncatedUpperCase(str) {\r\n    let upper = \"\";\r\n    for (let char of str) {\r\n        upper += char.toUpperCase()[0];\r\n    }\r\n    return upper;\r\n}\r\n\r\n//\r\n// Get character codes:\r\n// --------------------\r\n//\r\n// Get character codes map for a given string\r\n//\r\n\r\nfunction getCharCodes(str) {\r\n    let len = str.length;\r\n    let i = -1;\r\n\r\n    let charCodes = [];\r\n    // create map\r\n    while (++i < len) {\r\n        charCodes[str.charCodeAt(i)] = true;\r\n    }\r\n\r\n    return charCodes;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/query.js"],"sourceRoot":""}