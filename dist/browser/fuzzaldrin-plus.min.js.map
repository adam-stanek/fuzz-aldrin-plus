{"version":3,"sources":["webpack:///fuzzaldrin-plus.min.js","webpack:///webpack/bootstrap 1bf5549ba9fcf7dff3ec","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/scorer.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/pathScorer.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/fuzzaldrin-plus.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/filter.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/filterState.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/matcher.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/query.js","webpack:///./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/utils.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_classCallCheck","instance","Constructor","TypeError","score","string","preparedQuery","options","allowErrors","isMatch","core_lw","core_up","string_lw","toLowerCase","computeScore","Math","ceil","subject","query_lw","query_up","length","n","i","j","qj_lw","charCodeAt","qj_up","si","subject_lw","query","flexUppercase","current_score","acro","scoreAcronyms","acro_score","count","scoreExact","pos","indexOf","scoreExactMatch","score_row","Array","csc_row","sz","scoreSize","miss_budget","miss_coeff","miss_left","mm","lastIndexOf","csc_invalid","si_lw","charCodes","score_diag","csc_diag","record_miss","score_up","csc_score","qj","start","isWordStart","scoreConsecutives","align_score","scoreCharacter","curr_s","prev_s","isSeparator","isWordEnd","len","next_s","scorePosition","pos_bonus","sc","max","tau_size","abs","quality","wm","scorePattern","sameCase","end","bonus","posBonus","startOfWord","mi","nj","k","pos2","emptyAcronymResult","sepCount","sumPos","fullWord","isAcronymFullWord","AcronymResult","nbAcronymInQuery","__esModule","default","this","_scorer","scorePath","fullPathScore","useExtensionBonus","pathSeparator","basePos","fileLength","extAdjust","getExtensionScore","ext","depth","basePathScore","slice","alpha","tau_depth","countDir","file_coeff","path","getExtension","str","substr","candidate","startPos","endPos","maxDepth","matched","filter","candidates","checkString","checkCollection","parseOptions","getPreparedQuery","_filter","filterSync","filterAsync","callback","usePathScoring","_pathScorer","match","range","idx","_matcher","wrap","prepareQuery","obj","size","hasOwnProperty","Object","prototype","key","defaultOptions","preparedQueryCache","_query","Query","_typeof","Symbol","iterator","constructor","fuzzaldrin","defaultPathSeparator","process","toString","platform","window","optCharRegEx","_interopRequireDefault","state","_filterState","FilterStateInternal","executeFilter","internalState","publicState","FilterState","scheduled","setImmediate","setTimeout","shouldAbort","maxResults","outputScore","accessor","_utils2","isFunction","x","isActive","scoreProvider","scoredCandidates","processCollection","discardResults","sort","sortCandidates","map","pluckCandidates","collection","isArray","processItem","getIterator","item","next","isIteratorItem","done","value","cont","forEach","context","push","a","b","_scorer2","_pathScorer2","_utils","abort","keepResults","arguments","undefined","isCanceled","getProgressCount","matches","computeMatch","baseMatches","basenameMatch","mergeMatches","tagClass","tagOpen","tagClose","matchPositions","nbMatches","output","matchIndex","strPos","matchPos","substring","bj","out","ai","offset","STOP","UP","LEFT","DIAGONAL","trace","move","align","backtrack","reverse","coreChars","opt_char_re","replace","truncatedUpperCase","upper","_iterator","_isArray","_i","_ref","char","toUpperCase","getCharCodes","core","fn","tentativeArray","object","REAL_ITERATOR_SYMBOL","FAUX_ITERATOR_SYMBOL"],"mappings":"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","file":"fuzzaldrin-plus.min.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(3);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.score = score;\n\texports.isMatch = isMatch;\n\texports.computeScore = computeScore;\n\texports.isWordStart = isWordStart;\n\texports.isWordEnd = isWordEnd;\n\texports.isSeparator = isSeparator;\n\texports.scorePosition = scorePosition;\n\texports.scoreSize = scoreSize;\n\texports.scoreExact = scoreExact;\n\texports.scorePattern = scorePattern;\n\texports.scoreCharacter = scoreCharacter;\n\texports.scoreConsecutives = scoreConsecutives;\n\texports.scoreExactMatch = scoreExactMatch;\n\texports.scoreAcronyms = scoreAcronyms;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t//\n\t// Score similarity between two string\n\t//\n\t//  isMatch: Fast detection if all character of needle is in haystack\n\t//  score: Find string similarity using a Smith Waterman algorithm\n\t//         Modified to account for programing scenarios (CamelCase folder/file.ext object.property)\n\t//\n\t// Copyright (C) 2015 Jean Christophe Roy and contributors\n\t// MIT License: http://opensource.org/licenses/MIT\n\t\n\t\n\t// Base point for a single character match\n\t// This balance making patterns VS position and size penalty.\n\tvar wm = 150;\n\t\n\t//Fading function\n\tvar pos_bonus = 20; // The character from 0..pos_bonus receive a greater bonus for being at the init of string.\n\tvar tau_size = 85; // Full path length at which the whole match score is halved.\n\t\n\t// Miss count\n\t// When subject[i] is query[j] we register a hit.\n\t// Limiting hit put a boundary on how many permutation we consider to find the best one.\n\t// Helps to speed-up processing of long path and query containing frequent character (eg vowels)\n\t//\n\t// If a spec with frequent repetition fail, increase this.\n\t// This has a direct influence on worst case scenario benchmark.\n\tvar miss_coeff = 0.75; //Max number missed consecutive hit = ceil(miss_coeff*query.length) + 5\n\t\n\t\n\t//\n\t// Main export\n\t//\n\t\n\texports.default = {\n\t\n\t    score: score,\n\t    isMatch: isMatch\n\t\n\t};\n\t\n\t\n\t// Manage the logic of testing if there's a match and calling the main scoring function\n\t// Also manage scoring a path and optional character.\n\t\n\tfunction score(string, preparedQuery, options) {\n\t    var allowErrors = options.allowErrors;\n\t\n\t    if (!allowErrors && !isMatch(string, preparedQuery.core_lw, preparedQuery.core_up)) {\n\t        return 0;\n\t    }\n\t    var string_lw = string.toLowerCase();\n\t    var score = computeScore(string, string_lw, preparedQuery, options);\n\t    return Math.ceil(score);\n\t}\n\t\n\t//\n\t// isMatch:\n\t// Are all (non optional)characters of query in subject, in proper order ?\n\t//\n\t\n\tfunction isMatch(subject, query_lw, query_up) {\n\t    var m = subject.length;\n\t    var n = query_lw.length;\n\t\n\t    if (!m || n > m) {\n\t        return false;\n\t    }\n\t\n\t    var i = -1;\n\t    var j = -1;\n\t\n\t    //foreach char of query\n\t    while (++j < n) {\n\t\n\t        var qj_lw = query_lw.charCodeAt(j);\n\t        var qj_up = query_up.charCodeAt(j);\n\t\n\t        // Continue walking the subject from where we have left with previous query char\n\t        // until we have found a character that is either lowercase or uppercase query.\n\t        while (++i < m) {\n\t            var si = subject.charCodeAt(i);\n\t            if (si === qj_lw || si === qj_up) {\n\t                break;\n\t            }\n\t        }\n\t\n\t        // If we passed the last char, query is not in subject\n\t        if (i === m) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    // Found every char of query in subject in proper order, match is positive\n\t    return true;\n\t}\n\t\n\t//----------------------------------------------------------------------\n\t//\n\t// Main scoring algorithm\n\t//\n\t\n\tfunction computeScore(subject, subject_lw, preparedQuery, options) {\n\t    var query = preparedQuery.query,\n\t        query_lw = preparedQuery.query_lw;\n\t\n\t    var flexUppercase = true;\n\t\n\t    var m = subject.length;\n\t    var n = query.length;\n\t    var current_score = 0;\n\t\n\t    //----------------------------\n\t    // Abbreviations sequence\n\t\n\t    var acro = scoreAcronyms(subject, subject_lw, query, query_lw);\n\t    var acro_score = acro.score;\n\t\n\t    // Whole query is abbreviation ?\n\t    // => use that as score\n\t    if (acro.count === n) {\n\t        return scoreExact(n, m, acro_score, acro.pos);\n\t    }\n\t\n\t    //----------------------------\n\t    // Exact Match ?\n\t    // => use that as score\n\t\n\t    var pos = subject_lw.indexOf(query_lw);\n\t    if (pos > -1) {\n\t        return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);\n\t    }\n\t\n\t    //----------------------------\n\t    // Individual characters\n\t    // (Smith Waterman algorithm)\n\t\n\t\n\t    //Init\n\t    var score_row = new Array(n);\n\t    var csc_row = new Array(n);\n\t    var sz = scoreSize(n, m);\n\t\n\t    var miss_budget = Math.ceil(miss_coeff * n) + 5;\n\t    var miss_left = miss_budget;\n\t\n\t    //Fill with 0\n\t    var j = -1;\n\t    while (++j < n) {\n\t        score_row[j] = 0;\n\t        csc_row[j] = 0;\n\t    }\n\t\n\t    // Limit the search to the isActive region\n\t    // for example with query `abc`, subject `____a_bc_ac_c____`\n\t    // there's a region before first `a` and after last `c`\n\t    // that can be simplified out of the matching process\n\t\n\t    // Before first occurrence in subject of first letter of query, or -1\n\t    var i = subject_lw.indexOf(query_lw[0]);\n\t    if (i > -1) {\n\t        i--;\n\t    }\n\t\n\t    // After last occurrence of last letter of query,\n\t    var mm = subject_lw.lastIndexOf(query_lw[n - 1], m);\n\t    if (mm > i) {\n\t        m = mm + 1;\n\t    }\n\t\n\t    var csc_invalid = true;\n\t\n\t    while (++i < m) {\n\t        //foreach char si of subject\n\t\n\t        var si_lw = subject_lw[i];\n\t\n\t        // if si_lw is not in query\n\t        if (preparedQuery.charCodes[si_lw.charCodeAt(0)] == null) {\n\t            // reset csc_row and move to next\n\t            if (csc_invalid !== true) {\n\t                j = -1;\n\t                while (++j < n) {\n\t                    csc_row[j] = 0;\n\t                }\n\t                csc_invalid = true;\n\t            }\n\t            continue;\n\t        }\n\t\n\t        var si = subject_lw[i];\n\t\n\t        current_score = 0;\n\t        var score_diag = 0;\n\t        var csc_diag = 0;\n\t        var record_miss = true;\n\t        csc_invalid = false;\n\t\n\t        j = -1; //0..n-1\n\t        while (++j < n) {\n\t            //foreach char qj of query\n\t\n\t            // What is the best gap ?\n\t            // score_up contain the score of a gap in subject.\n\t            // score_left = last iteration of score, -> gap in query.\n\t            var score_up = score_row[j];\n\t            if (score_up > current_score) {\n\t                current_score = score_up;\n\t            }\n\t\n\t            //Reset consecutive\n\t            var csc_score = 0;\n\t            var qj_lw = query_lw[j];\n\t\n\t            // Compute a tentative match\n\t            // First check case-insesitive match\n\t            if (qj_lw === si_lw) {\n\t\n\t                // Refine for strict Uppercase\n\t                //\n\t                // When do we have a match ?\n\t                // A) Case Insensitive Match && Not strict Uppercase\n\t                // B) Case Insensitive Match && Query is lowercase\n\t                // C) Case Sensitive Match. (Imply Case Insensitive)\n\t\n\t                var qj = query[j];\n\t                if (flexUppercase || qj_lw === qj || si === qj) {\n\t\n\t                    var start = isWordStart(i, subject, subject_lw);\n\t\n\t                    // Forward search for a sequence of consecutive char\n\t                    csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n\t\n\t                    // Determine bonus for matching A[i] with B[j]\n\t                    var align_score = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n\t\n\t                    //Are we better using this match or taking the best gap (currently stored in score)?\n\t                    if (align_score > current_score) {\n\t                        current_score = align_score;\n\t                        // reset consecutive missed hit count\n\t                        miss_left = miss_budget;\n\t                    } else {\n\t                        // We rejected this match and record a miss.\n\t                        // If budget is exhausted exit\n\t                        if (record_miss && --miss_left <= 0) {\n\t                            return score_row[n - 1] * sz;\n\t                        }\n\t                        record_miss = false;\n\t                    }\n\t                }\n\t            }\n\t\n\t            //Prepare next sequence & match score.\n\t            score_diag = score_up;\n\t            csc_diag = csc_row[j];\n\t            csc_row[j] = csc_score;\n\t            score_row[j] = current_score;\n\t        }\n\t    }\n\t\n\t    // get highest score so far\n\t    current_score = score_row[n - 1];\n\t    return current_score * sz;\n\t}\n\t\n\t//\n\t// Boundaries\n\t//\n\t// Is the character at the init of a word, end of the word, or a separator ?\n\t// Fortunately those small function inline well.\n\t//\n\t\n\tfunction isWordStart(pos, subject, subject_lw) {\n\t    if (pos === 0) {\n\t        return true;\n\t    } // match is FIRST char ( place a virtual token separator before first char of string)\n\t    var curr_s = subject[pos];\n\t    var prev_s = subject[pos - 1];\n\t    return isSeparator(prev_s) || // match FOLLOW a separator\n\t    curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1]; // match is Capital in camelCase (preceded by lowercase)\n\t}\n\t\n\tfunction isWordEnd(pos, subject, subject_lw, len) {\n\t    if (pos === len - 1) {\n\t        return true;\n\t    } // last char of string\n\t    var curr_s = subject[pos];\n\t    var next_s = subject[pos + 1];\n\t    return isSeparator(next_s) || // match IS FOLLOWED BY a separator\n\t    curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1]; // match is lowercase, followed by uppercase\n\t}\n\t\n\tfunction isSeparator(c) {\n\t    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\\\';\n\t}\n\t//\n\t// Scoring helper\n\t//\n\t\n\tfunction scorePosition(pos) {\n\t    if (pos < pos_bonus) {\n\t        var sc = pos_bonus - pos;\n\t        return 100 + sc * sc;\n\t    } else {\n\t        return Math.max(100 + pos_bonus - pos, 0);\n\t    }\n\t}\n\t\n\tfunction scoreSize(n, m) {\n\t    // Size penalty, use the difference of size (m-n)\n\t    return tau_size / (tau_size + Math.abs(m - n));\n\t}\n\t\n\tfunction scoreExact(n, m, quality, pos) {\n\t    return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);\n\t}\n\t\n\t//\n\t// Shared scoring logic between exact match, consecutive & acronym\n\t// Ensure pattern length dominate the score then refine to take into account case-sensitivity\n\t// and structural quality of the pattern on the overall string (word boundary)\n\t//\n\t\n\tfunction scorePattern(count, len, sameCase, start, end) {\n\t    var sz = count;\n\t\n\t    var bonus = 6; // to ensure consecutive length dominate score, this should be as large other bonus combined\n\t    if (sameCase === count) {\n\t        bonus += 2;\n\t    }\n\t    if (start) {\n\t        bonus += 3;\n\t    }\n\t    if (end) {\n\t        bonus += 1;\n\t    }\n\t\n\t    if (count === len) {\n\t        // when we match 100% of query we allow to break the size ordering.\n\t        // This is to help exact match bubble up vs size, depth penalty etc\n\t        if (start) {\n\t            if (sameCase === len) {\n\t                sz += 2;\n\t            } else {\n\t                sz += 1;\n\t            }\n\t        }\n\t        if (end) {\n\t            bonus += 1;\n\t        }\n\t    }\n\t\n\t    return sameCase + sz * (sz + bonus);\n\t}\n\t\n\t//\n\t// Compute the bonuses for two chars that are confirmed to matches in a case-insensitive way\n\t//\n\t\n\tfunction scoreCharacter(i, j, start, acro_score, csc_score) {\n\t\n\t    // init of string / position of match bonus\n\t    var posBonus = scorePosition(i);\n\t\n\t    // match IS a word boundary\n\t    // choose between taking part of consecutive characters or consecutive acronym\n\t    if (start) {\n\t        return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);\n\t    }\n\t\n\t    // normal Match\n\t    return posBonus + wm * csc_score;\n\t}\n\t\n\t//\n\t// Forward search for a sequence of consecutive character.\n\t//\n\t\n\tfunction scoreConsecutives(subject, subject_lw, query, query_lw, i, j, startOfWord) {\n\t    var m = subject.length;\n\t    var n = query.length;\n\t\n\t    var mi = m - i;\n\t    var nj = n - j;\n\t    var k = mi < nj ? mi : nj;\n\t\n\t    var sameCase = 0;\n\t\n\t    // query_lw[i] is subject_lw[j] has been checked before entering now do case sensitive check.\n\t    if (query[j] === subject[i]) {\n\t        sameCase++;\n\t    }\n\t\n\t    // size of consecutive\n\t    // sz will be one more than the last index where query[j] == subject[i] (lowercase)\n\t    var sz = 0;\n\t\n\t    //Continue while lowercase char are the same, record when they are case-sensitive match.\n\t    while (++sz < k && query_lw[++j] === subject_lw[++i]) {\n\t        if (query[j] === subject[i]) {\n\t            sameCase++;\n\t        }\n\t    }\n\t\n\t    // Faster path for single match.\n\t    // Isolated character match occurs often and are not really interesting.\n\t    // Fast path so we don't compute expensive pattern score on them.\n\t    // Acronym should be addressed with acronym context bonus instead of consecutive.\n\t    if (sz === 1) {\n\t        return 1 + 2 * sameCase;\n\t    }\n\t\n\t    return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));\n\t}\n\t\n\t//\n\t// Compute the score of an exact match at position pos.\n\t//\n\t\n\tfunction scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m) {\n\t\n\t    // Test for word init\n\t    var start = isWordStart(pos, subject, subject_lw);\n\t\n\t    // Heuristic\n\t    // If not a word init, test next occurrence\n\t    // - We want exact match to be fast\n\t    // - For exact match, word init has the biggest impact on score.\n\t    // - Testing 2 instances is somewhere between testing only one and testing every instances.\n\t\n\t    if (!start) {\n\t        var pos2 = subject_lw.indexOf(query_lw, pos + 1);\n\t        if (pos2 > -1) {\n\t            start = isWordStart(pos2, subject, subject_lw);\n\t            if (start) {\n\t                pos = pos2;\n\t            }\n\t        }\n\t    }\n\t\n\t    //Exact case bonus.\n\t    var i = -1;\n\t    var sameCase = 0;\n\t    while (++i < n) {\n\t        if (query[pos + i] === subject[i]) {\n\t            sameCase++;\n\t        }\n\t    }\n\t\n\t    var end = isWordEnd(pos + n - 1, subject, subject_lw, m);\n\t\n\t    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);\n\t}\n\t\n\t//\n\t// Acronym prefix\n\t//\n\t\n\t\n\tvar AcronymResult = function AcronymResult(score, pos, count) {\n\t    _classCallCheck(this, AcronymResult);\n\t\n\t    this.score = score;\n\t    this.pos = pos;\n\t    this.count = count;\n\t};\n\t\n\tvar emptyAcronymResult = new AcronymResult(0, 0.1, 0);\n\t\n\tfunction scoreAcronyms(subject, subject_lw, query, query_lw) {\n\t    var m = subject.length;\n\t    var n = query.length;\n\t\n\t    //a single char is not an acronym\n\t    if (m <= 1 || n <= 1) {\n\t        return emptyAcronymResult;\n\t    }\n\t\n\t    var count = 0;\n\t    var sepCount = 0;\n\t    var sumPos = 0;\n\t    var sameCase = 0;\n\t\n\t    var i = -1;\n\t    var j = -1;\n\t\n\t    //foreach char of query\n\t    while (++j < n) {\n\t\n\t        var qj_lw = query_lw[j];\n\t\n\t        // Separator will not score point but will continue the prefix when present.\n\t        // Test that the separator is in the candidate and advance cursor to that position.\n\t        // If no separator break the prefix\n\t\n\t        if (isSeparator(qj_lw)) {\n\t            i = subject_lw.indexOf(qj_lw, i + 1);\n\t            if (i > -1) {\n\t                sepCount++;\n\t                continue;\n\t            } else {\n\t                break;\n\t            }\n\t        }\n\t\n\t        // For other characters we search for the first match where subject[i] = query[j]\n\t        // that also happens to be a init-of-word\n\t\n\t        while (++i < m) {\n\t            if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {\n\t                if (query[j] === subject[i]) {\n\t                    sameCase++;\n\t                }\n\t                sumPos += i;\n\t                count++;\n\t                break;\n\t            }\n\t        }\n\t\n\t        // All of subject is consumed, stop processing the query.\n\t        if (i === m) {\n\t            break;\n\t        }\n\t    }\n\t\n\t    // Here, all of query is consumed (or we have reached a character not in acronym)\n\t    // A single character is not an acronym (also prevent division by 0)\n\t    if (count < 2) {\n\t        return emptyAcronymResult;\n\t    }\n\t\n\t    // Acronym are scored as init-of-word\n\t    // Unless the acronym is a 1:1 match with candidate then it is upgraded to full-word.\n\t    var fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;\n\t    var score = scorePattern(count, n, sameCase, true, fullWord);\n\t\n\t    return new AcronymResult(score, sumPos / count, count + sepCount);\n\t}\n\t\n\t//\n\t// Test whether there's a 1:1 relationship between query and acronym of candidate.\n\t// For that to happens\n\t// (a) All character of query must be matched to an acronym of candidate\n\t// (b) All acronym of candidate must be matched to a character of query.\n\t//\n\t// This method check for (b) assuming (a) has been checked before entering.\n\t\n\tfunction isAcronymFullWord(subject, subject_lw, query, nbAcronymInQuery) {\n\t    var m = subject.length;\n\t    var n = query.length;\n\t    var count = 0;\n\t\n\t    // Heuristic:\n\t    // Assume one acronym every (at most) 12 character on average\n\t    // This filter out long paths, but then they can match on the filename.\n\t    if (m > 12 * n) {\n\t        return false;\n\t    }\n\t\n\t    var i = -1;\n\t    while (++i < m) {\n\t        //For each char of subject\n\t        //Test if we have an acronym, if so increase acronym count.\n\t        //If the acronym count is more than nbAcronymInQuery (number of non separator char in query)\n\t        //Then we do not have 1:1 relationship.\n\t        if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {\n\t            return false;\n\t        }\n\t    }\n\t\n\t    return true;\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.score = score;\n\texports.countDir = countDir;\n\texports.getExtension = getExtension;\n\texports.getExtensionScore = getExtensionScore;\n\t\n\tvar _scorer = __webpack_require__(1);\n\t\n\tvar tau_depth = 13; //  Directory depth at which the full path influence is halved.\n\tvar file_coeff = 1.2; //  Full path is also penalized for length of basename. This adjust a scale factor for that penalty.\n\t\n\texports.default = {\n\t    score: score,\n\t    countDir: countDir,\n\t    getExtensionScore: getExtensionScore\n\t};\n\t\n\t//  Manage the logic of testing if there's a match and calling the main scoring function\n\t//  Also manage scoring a path and optional character.\n\t\n\tfunction score(string, preparedQuery, options) {\n\t    var allowErrors = options.allowErrors;\n\t\n\t    if (!allowErrors && !(0, _scorer.isMatch)(string, preparedQuery.core_lw, preparedQuery.core_up)) {\n\t        return 0;\n\t    }\n\t    var string_lw = string.toLowerCase();\n\t    var score = (0, _scorer.computeScore)(string, string_lw, preparedQuery, options);\n\t    score = scorePath(string, string_lw, score, preparedQuery, options);\n\t    return Math.ceil(score);\n\t}\n\t\n\t// \n\t//  Score adjustment for path\n\t// \n\t\n\tfunction scorePath(subject, subject_lw, fullPathScore, preparedQuery, options) {\n\t\n\t    if (fullPathScore === 0) {\n\t        return 0;\n\t    }\n\t\n\t    var useExtensionBonus = options.useExtensionBonus,\n\t        pathSeparator = options.pathSeparator;\n\t\n\t    //  Skip trailing slashes\n\t\n\t    var end = subject.length - 1;\n\t    while (subject[end] === pathSeparator) {\n\t        end--;\n\t    }\n\t\n\t    //  Get position of basePath of subject.\n\t    var basePos = subject.lastIndexOf(pathSeparator, end);\n\t    var fileLength = end - basePos;\n\t\n\t    //  Get a bonus for matching extension\n\t    var extAdjust = 1.0;\n\t\n\t    if (useExtensionBonus) {\n\t        extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);\n\t        fullPathScore *= extAdjust;\n\t    }\n\t\n\t    //  no basePath, nothing else to compute.\n\t    if (basePos === -1) {\n\t        return fullPathScore;\n\t    }\n\t\n\t    //  Get the number of folder in query\n\t    var depth = preparedQuery.depth;\n\t\n\t    //  Get that many folder from subject\n\t\n\t    while (basePos > -1 && depth-- > 0) {\n\t        basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n\t    }\n\t\n\t    //  Get basePath score, if BaseName is the whole string, no need to recompute\n\t    //  We still need to apply the folder depth and filename penalty.\n\t    var basePathScore = basePos === -1 ? fullPathScore : extAdjust * (0, _scorer.computeScore)(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery, options);\n\t\n\t    //  Final score is linear interpolation between base score and full path score.\n\t    //  For low directory depth, interpolation favor base Path then include more of full path as depth increase\n\t    //\n\t    //  A penalty based on the size of the basePath is applied to fullPathScore\n\t    //  That way, more focused basePath match can overcome longer directory path.\n\t\n\t    var alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1, pathSeparator));\n\t    return alpha * basePathScore + (1 - alpha) * fullPathScore * (0, _scorer.scoreSize)(0, file_coeff * fileLength);\n\t}\n\t\n\t// \n\t//  Count number of folder in a path.\n\t//  (consecutive slashes count as a single directory)\n\t// \n\t\n\tfunction countDir(path, end, pathSeparator) {\n\t    if (end < 1) {\n\t        return 0;\n\t    }\n\t\n\t    var count = 0;\n\t    var i = 0;\n\t\n\t    // skip slash at the start of string\n\t    // so `foo/bar` and `/foo/bar` have the same depth.\n\t    while (i < end && path[i] === pathSeparator) {\n\t        i++;\n\t    }\n\t\n\t    // scan for path separator\n\t    while (i < end) {\n\t\n\t        if (path[i] === pathSeparator) {\n\t\n\t            //When path found increase directory depth\n\t            count++;\n\t\n\t            //But treat multiple consecutive pathSeparator as one\n\t            while (i < end && path[i] === pathSeparator) {\n\t                i++;\n\t            }\n\t        }\n\t\n\t        i++;\n\t    }\n\t\n\t    return count;\n\t}\n\t\n\t// \n\t//  Find fraction of extension that is matched by query.\n\t//  For example mf.h prefers myFile.h to myfile.html\n\t//  This need special handling because it give point for not having characters (the `tml` in above example)\n\t// \n\t\n\tfunction getExtension(str) {\n\t    var pos = str.lastIndexOf(\".\");\n\t    if (pos < 0) {\n\t        return \"\";\n\t    } else {\n\t        return str.substr(pos + 1);\n\t    }\n\t}\n\t\n\tfunction getExtensionScore(candidate, ext, startPos, endPos, maxDepth) {\n\t    //  startPos is the position of last slash of candidate, -1 if absent.\n\t\n\t    if (ext == null || !ext.length) {\n\t        return 0;\n\t    }\n\t\n\t    //  Check that (a) extension exist, (b) it is after the init of the basename\n\t    var pos = candidate.lastIndexOf(\".\", endPos);\n\t    if (pos <= startPos) {\n\t        return 0;\n\t    } //  (note that startPos >= -1)\n\t\n\t    var n = ext.length;\n\t    var m = endPos - pos;\n\t\n\t    //  n contain the smallest of both extension length, m the largest.\n\t    if (m < n) {\n\t        n = m;\n\t        m = ext.length;\n\t    }\n\t\n\t    // place cursor after dot & count number of matching characters in extension\n\t    pos++;\n\t    var matched = -1;\n\t    while (++matched < n) {\n\t        if (candidate[pos + matched] !== ext[matched]) {\n\t            break;\n\t        }\n\t    }\n\t\n\t    //  if nothing found, try deeper for multiple extensions, with some penalty for depth\n\t    if (matched === 0 && maxDepth > 0) {\n\t        return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);\n\t    }\n\t\n\t    //  cannot divide by zero because m is the largest extension length and we return if either is 0\n\t    return matched / m;\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\texports.filter = filter;\n\texports.filterAsync = filterAsync;\n\texports.score = score;\n\texports.match = match;\n\texports.wrap = wrap;\n\texports.prepareQuery = prepareQuery;\n\t\n\tvar _filter = __webpack_require__(4);\n\t\n\tvar _scorer = __webpack_require__(1);\n\t\n\tvar _pathScorer = __webpack_require__(2);\n\t\n\tvar _matcher = __webpack_require__(6);\n\t\n\tvar _query = __webpack_require__(7);\n\t\n\tvar fuzzaldrin = {\n\t    filter: filter,\n\t    score: score,\n\t    match: match,\n\t    wrap: wrap,\n\t    prepareQuery: prepareQuery\n\t};\n\t\n\texports.default = fuzzaldrin;\n\t\n\t\n\tvar preparedQueryCache = null;\n\t\n\t/**\r\n\t * Filter:\r\n\t *  Given a list of candidate, output a list of candidate that match query.\r\n\t *  Output list is the same format (string or object) than input list.\r\n\t *\r\n\t *  If given a list of object, specify options.key as the property `candidate[key]`\r\n\t *  that contain the string representation of the candidate\r\n\t *\r\n\t *  Output is sorted by match score.\r\n\t *\r\n\t * @param {Array.<(string|object)>|Iterable} candidates - array of string or objects\r\n\t * @param {string} query - string to search for in each candidate\r\n\t * @param {FilterOptions=} options - (optional) see option hash doc\r\n\t * @returns {Array.<(string|object)>} - filtered & sorted subset of input candidates\r\n\t */\n\t\n\tfunction filter(candidates, query, options) {\n\t\n\t    if (!checkString(query)) return [];\n\t    if (!checkCollection(candidates)) return [];\n\t\n\t    options = parseOptions(options);\n\t    var preparedQuery = getPreparedQuery(query, options);\n\t\n\t    return (0, _filter.filterSync)(candidates, preparedQuery, options);\n\t}\n\t\n\t/**\r\n\t *\r\n\t * @param candidates\r\n\t * @param query\r\n\t * @param options\r\n\t * @param {filterCallback} callback\r\n\t * @returns {FilterState}\r\n\t */\n\t\n\tfunction filterAsync(candidates, query, callback, options) {\n\t\n\t    if (!checkString(query)) return [];\n\t    if (!checkCollection(candidates)) return [];\n\t\n\t    options = parseOptions(options);\n\t    var preparedQuery = getPreparedQuery(query, options);\n\t\n\t    return (0, _filter.filterAsync)(candidates, preparedQuery, callback, options);\n\t}\n\t\n\t/**\r\n\t * Score:\r\n\t *   Give the numerical score on how a given string match query.\r\n\t *\r\n\t *   This is provided so you can build your own filter method.\r\n\t *   For example you may have a special way to iterate candidate,\r\n\t *   access candidate string representation, or you may need to\r\n\t *   modify the score to account external knowledge (eg last modified date)\r\n\t *\r\n\t * @param {string} string - string representation of a candidate\r\n\t * @param {string} query - string to search for in candidate\r\n\t * @param {ScoringOptions=} options - (optional) see option hash doc\r\n\t * @returns {number} score 0 .. max, where max is score(string, string)\r\n\t */\n\t\n\tfunction score(string, query, options) {\n\t\n\t    if (!checkString(string)) return 0;\n\t    if (!checkString(query)) return 0;\n\t\n\t    options = parseOptions(options);\n\t    var preparedQuery = getPreparedQuery(query, options);\n\t\n\t    if (options.usePathScoring) {\n\t        return (0, _pathScorer.score)(string, preparedQuery, options);\n\t    } else {\n\t        return (0, _scorer.score)(string, preparedQuery, options);\n\t    }\n\t}\n\t\n\t/**\r\n\t * Match:\r\n\t *    Communicate which characters of candidate where selected by the algorithm to represent the query.\r\n\t *    The match function output an array of character position.\r\n\t *    If you need to display those character as an html string see wrap function.\r\n\t *\r\n\t * @param {string} string - string representation of a candidate\r\n\t * @param {string} query - string to search for in candidate\r\n\t * @param {MatchOptions=} options (optional)\r\n\t * @returns {Array.<number>}\r\n\t */\n\t\n\tfunction match(string, query, options) {\n\t\n\t    if (!checkString(string)) return [];\n\t    if (!checkString(query)) return [];\n\t\n\t    //If both are the same, return an array of consecutive numbers\n\t    if (string === query) {\n\t        var length = string.length;\n\t        var range = new Array(length);\n\t        for (var idx = 0; idx < length; idx++) {\n\t            range[idx] = idx;\n\t        }\n\t        return range;\n\t    }\n\t\n\t    options = parseOptions(options);\n\t    var preparedQuery = getPreparedQuery(query, options);\n\t\n\t    return (0, _matcher.match)(string, preparedQuery, options);\n\t}\n\t\n\t/**\r\n\t * Wrap:\r\n\t *    Communicate which characters of candidate where selected by the algorithm to represent the query.\r\n\t *    This function output the given string with chosen character wrapped in a delimiter string (eg html tag).\r\n\t *\r\n\t *    To control the wrap use the option hash.\r\n\t *    Here are some default value:\r\n\t *      options.tagOpen = `<strong class=\"highlight\">`\r\n\t *      options.tagClose = `</strong>`\r\n\t *\r\n\t *    Alternatively, if you chose to keep the default tagOpen,\r\n\t *    you can specify option.tagClass and change the `highlight`\r\n\t *    class to one of your choosing.\r\n\t *\r\n\t *    Wrap method will try to group consecutive matches under the same tag.\r\n\t *\r\n\t * @param {string} string - string representation of a candidate\r\n\t * @param {string} query - string to search for in candidate\r\n\t * @param {WrapOptions=} options\r\n\t * @returns {string} - input string with match wrapped in open and close tag.\r\n\t */\n\t\n\tfunction wrap(string, query, options) {\n\t\n\t    if (!checkString(string)) return \"\";\n\t    if (!checkString(query)) return string;\n\t\n\t    options = parseOptions(options);\n\t    var preparedQuery = getPreparedQuery(query, options);\n\t\n\t    return (0, _matcher.wrap)(string, query, options);\n\t}\n\t\n\t/**\r\n\t * PrepareQuery:\r\n\t *   The usual scenario is to compare a single query with multiple candidate.\r\n\t *   To speed that process up, we pre-compute some information about the query.\r\n\t *\r\n\t *   Pre-computed query is natural to use in bulk method like filter, but harder\r\n\t *   in one-by-one method like score or match. To keep those method fast you can give\r\n\t *   a pre computed query in option hash as `options.preparedQuery`\r\n\t *\r\n\t *   Note that we use an internal cache `preparedQueryCache` that cover most of the simple cases\r\n\t *   So this method may not be needed in thos cases.\r\n\t *\r\n\t * @param {string} query\r\n\t * @param {QueryOptions} options\r\n\t * @returns {Query}\r\n\t */\n\t\n\tfunction prepareQuery(query, options) {\n\t    options = parseOptions(options);\n\t    return getPreparedQuery(query, options);\n\t}\n\t\n\tfunction checkString(str) {\n\t    //Not null, must have length property > 0\n\t    return str != null && str.length != null && str.length > 0;\n\t}\n\t\n\tfunction checkCollection(obj) {\n\t    // Not null\n\t    // If object has length or size property, must be != 0\n\t    // Example of thing with size: (es6 sets, ImmutableJs collections)\n\t    return obj != null && obj.length !== 0 && obj.size !== 0;\n\t}\n\t\n\t//\n\t// Detect node.js or browser to set default path separator\n\t//\n\t\n\tvar defaultPathSeparator = \"/\";\n\t\n\tif ((typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === 'object' && Object.prototype.toString.call(process) === '[object process]') {\n\t\n\t    // On node js we assume the list of candidates match local OS path format.\n\t    // See comment bellow to change behavior.\n\t    defaultPathSeparator = process.platform === \"win32\" ? '\\\\' : '/';\n\t} else if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' && Object.prototype.toString.call(window) === \"[object Window]\") {\n\t\n\t    // We assume that browser are dealing with url, if assumption is false use option hash like so:\n\t    // fuzzaldrin.filter( candidates, query, {pathSeparator: platformSep} )\n\t    // and determine `platformSep` any so it match the format of candidates.\n\t\n\t    defaultPathSeparator = \"/\";\n\t\n\t    // Export main object to global window.\n\t    window.fuzzaldrin = fuzzaldrin;\n\t}\n\t\n\t//\n\t// Setup default values\n\t//\n\t\n\t/**\r\n\t * @type {ScoringOptions}\r\n\t */\n\tvar defaultOptions = {\n\t    allowErrors: false,\n\t    usePathScoring: true,\n\t    useExtensionBonus: false,\n\t    pathSeparator: defaultPathSeparator,\n\t    optCharRegEx: null,\n\t    preparedQuery: null\n\t};\n\t\n\t/**\r\n\t *\r\n\t * @param {(ScoringOptions|FilterOptions|MatchOptions|WrapOptions)} options\r\n\t * @returns {(ScoringOptions|FilterOptions|MatchOptions|WrapOptions)} options completed with default values from ScoringOptions\r\n\t */\n\t\n\tfunction parseOptions(options) {\n\t\n\t    // If no options given, copy default\n\t    // Else merge options with defaults.\n\t\n\t    if (options == null) options = {};\n\t\n\t    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\t    for (var key in defaultOptions) {\n\t        if (hasOwnProperty.call(defaultOptions, key) && !hasOwnProperty.call(options, key)) {\n\t            options[key] = defaultOptions[key];\n\t        }\n\t    }\n\t\n\t    return options;\n\t}\n\t\n\tfunction getPreparedQuery(query, options) {\n\t\n\t    // If prepared query in option hash is valid, use it\n\t    if (options.preparedQuery != null && options.preparedQuery.query === query) return options.preparedQuery;\n\t\n\t    // Recompute cache if empty or invalid\n\t    if (preparedQueryCache == null || preparedQueryCache.query !== query) {\n\t        preparedQueryCache = new _query.Query(query, options);\n\t    }\n\t\n\t    // Serve from cache\n\t    return preparedQueryCache;\n\t}\n\t\n\t//\n\t// Documentation for option hash\n\t//\n\t\n\t/**\r\n\t * @typedef {Object} QueryOptions\r\n\t * @property {string} pathSeparator - If candidate are path, indicate path separator used (usually '/' or '\\\\').\r\n\t * @property {RegExp} optCharRegEx - Regex that identify character that does not have to match exactly, for example <whitespace>.\r\n\t *\r\n\t */\n\t\n\t/**\r\n\t * @typedef {Object} ScoringOptions\r\n\t * @extends QueryOptions\r\n\t *\r\n\t * @property {boolean} allowErrors - Should we allow candidates that does not have all characters of query ?\r\n\t * @property {boolean} usePathScoring - Should we try to interpret candidates as path\r\n\t * @property {boolean} useExtensionBonus - Should we try to interpret extension from query\r\n\t *                                         and prefer files that match that extension (needs usePathScoring)\r\n\t * @property {Query} preparedQuery - If you have a precomputed query object set it here.\r\n\t */\n\t\n\t/**\r\n\t * @typedef {Object} FilterOptions\r\n\t * @extends ScoringOptions\r\n\t *\r\n\t * @property {string|function} key - Name of the property that contain string ot be scored\r\n\t *                                   or function that input candidate and output string to be scored.\r\n\t *\r\n\t * @property {number} maxResults - Output the top `maxResults` best results at most.\r\n\t * @property {bool} outputScore - If true output is an array of {candidate,score} else output is an array of candidates\r\n\t *\r\n\t */\n\t\n\t/**\r\n\t * @typedef {Object} MatchOptions\r\n\t * @extends ScoringOptions\r\n\t *\r\n\t *\r\n\t */\n\t\n\t/**\r\n\t * @typedef {Object} WrapOptions\r\n\t * @extends MatchOptions\r\n\t *\r\n\t * @property {string} tagOpen - string to place before a match default to `<strong class=\"highlight\">`\r\n\t * @property {string} tagClose - string to place after a match default to `</strong>`\r\n\t * @property {string} tagClass - change the class of the default open tag (tagOpen must be unset)\r\n\t *\r\n\t */\n\t\n\t//\n\t// Async\n\t//\n\t\n\t/**\r\n\t * @callback filterCallback\r\n\t * @param {Array} results\r\n\t * @param {FilterState} state\r\n\t */\n\t\n\t/**\r\n\t * @typedef {Object} FilterState\r\n\t *\r\n\t * @method  abort - stop scoring and return no results.\r\n\t * @method  isActive - is the filter running.\r\n\t * @method  isCanceled - has the filter been canceled.\r\n\t * @method  getProgressCount - get the count of processed elements.\r\n\t *\r\n\t */\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.filterSync = filterSync;\n\texports.filterAsync = filterAsync;\n\t\n\tvar _scorer = __webpack_require__(1);\n\t\n\tvar _scorer2 = _interopRequireDefault(_scorer);\n\t\n\tvar _pathScorer = __webpack_require__(2);\n\t\n\tvar _pathScorer2 = _interopRequireDefault(_pathScorer);\n\t\n\tvar _utils = __webpack_require__(8);\n\t\n\tvar _utils2 = _interopRequireDefault(_utils);\n\t\n\tvar _filterState = __webpack_require__(5);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\texports.default = {\n\t    filterSync: filterSync,\n\t    filterAsync: filterAsync\n\t};\n\t\n\t/**\r\n\t *\r\n\t * @param {Array|Iterable} candidates\r\n\t * @param {Query} preparedQuery\r\n\t * @param {FilterOptions} options\r\n\t * @returns {Array}\r\n\t */\n\t\n\tfunction filterSync(candidates, preparedQuery, options) {\n\t    var state = new _filterState.FilterStateInternal();\n\t    return executeFilter(candidates, preparedQuery, state, options);\n\t}\n\t\n\t/**\r\n\t *\r\n\t * @param {Array|Iterable} candidates\r\n\t * @param {Query} preparedQuery\r\n\t * @param {FilterOptions} options\r\n\t * @param {filterCallback} callback\r\n\t * @returns {FilterState}\r\n\t */\n\t\n\tfunction filterAsync(candidates, preparedQuery, callback, options) {\n\t\n\t    var internalState = new _filterState.FilterStateInternal();\n\t    var publicState = new _filterState.FilterState(internalState);\n\t\n\t    var scheduled = function scheduled() {\n\t        callback(executeFilter(candidates, preparedQuery, internalState, options), publicState);\n\t    };\n\t\n\t    if (typeof setImmediate === \"function\") {\n\t        setImmediate(scheduled);\n\t    } else {\n\t        setTimeout(scheduled, 0);\n\t    }\n\t\n\t    return publicState;\n\t}\n\t\n\t/**\r\n\t *\r\n\t * @param {Array|Iterable} candidates\r\n\t * @param {Query} preparedQuery\r\n\t * @param {FilterStateInternal} state\r\n\t * @param {FilterOptions} options\r\n\t * @returns {Array}\r\n\t */\n\t\n\tfunction executeFilter(candidates, preparedQuery, state, options) {\n\t\n\t    if (state.shouldAbort) return [];\n\t\n\t    // See option parsing on main module for default\n\t    var key = options.key,\n\t        maxResults = options.maxResults,\n\t        outputScore = options.outputScore,\n\t        usePathScoring = options.usePathScoring;\n\t\n\t    // If list of object, we need to get the string to be scored, as defined by options.key\n\t    // If the key is a method, that method should take an object and return the string.\n\t    // Else we assume it is the name of a property on candidate object.\n\t\n\t    var accessor = null;\n\t    if (key != null) {\n\t        accessor = _utils2.default.isFunction(options.key) ? options.key : function (x) {\n\t            return x[key];\n\t        };\n\t    }\n\t\n\t    // Init state\n\t    state.isActive = true;\n\t    state.accessor = accessor;\n\t    state.scoreProvider = usePathScoring ? _pathScorer2.default : _scorer2.default;\n\t    state.scoredCandidates = [];\n\t\n\t    // Iterate candidate list and collect scored positive matches.\n\t    processCollection(candidates, preparedQuery, state, options);\n\t\n\t    // Collect positives matches\n\t    var scoredCandidates = state.scoredCandidates;\n\t\n\t    // Cleanup\n\t    state.scoredCandidates = null;\n\t    state.isActive = false;\n\t\n\t    // Quick exit\n\t    if (state.discardResults || scoredCandidates == null || !scoredCandidates.length) return [];\n\t\n\t    // Sort scores in descending order\n\t    scoredCandidates.sort(sortCandidates);\n\t\n\t    // Trim to maxResults if specified\n\t    if (maxResults != null) {\n\t        scoredCandidates = scoredCandidates.slice(0, maxResults);\n\t    }\n\t\n\t    // Return either a sorted list of candidate or list of candidate-score pairs.\n\t    if (outputScore === true) {\n\t        return scoredCandidates;\n\t    } else {\n\t        // Extract original candidate and return\n\t        return scoredCandidates.map(pluckCandidates);\n\t    }\n\t}\n\t\n\tfunction processCollection(collection, preparedQuery, state, options) {\n\t\n\t    //\n\t    // Collection is an array\n\t    //\n\t\n\t    if (_utils2.default.isArray(collection)) {\n\t        for (var i = 0; i <= collection.length; i++) {\n\t            if (!processItem(collection[i], preparedQuery, state, options)) break;\n\t        }\n\t        return true;\n\t    }\n\t\n\t    //\n\t    // Collection is an Iterable or Iterator (es6 protocol)\n\t    //\n\t\n\t    var iterator = _utils2.default.getIterator(collection);\n\t    if (iterator != null) {\n\t        var item = iterator.next();\n\t        if (_utils2.default.isIteratorItem(item)) {\n\t            while (!item.done) {\n\t                if (!processItem(item.value, preparedQuery, state, options)) break;\n\t                item = iterator.next();\n\t            }\n\t            return true;\n\t        }\n\t    }\n\t\n\t    //\n\t    // Collection implements 'forEach'\n\t    //\n\t\n\t    // Some implementations  of foreach allow to exit using return false. (Eg Immutablejs)\n\t    //      processItem follow that convention .\n\t    //\n\t    // Others cannot be interrupted ( Eg default Array.forEach )\n\t    //      so we continue iteration but short circuit most of the work.\n\t\n\t    var cont = true;\n\t    if (_utils2.default.isFunction(collection.forEach)) {\n\t        collection.forEach(function (item) {\n\t            return cont = cont && processItem(item, preparedQuery, state, options);\n\t        });\n\t        return true;\n\t    }\n\t\n\t    return false;\n\t}\n\t\n\t/**\r\n\t *\r\n\t * @param {string|object} candidate\r\n\t * @param {Query} preparedQuery\r\n\t * @param {FilterStateInternal} context\r\n\t * @param {FilterOptions} options\r\n\t * @returns {boolean}\r\n\t */\n\t\n\tfunction processItem(candidate, preparedQuery, context, options) {\n\t\n\t    if (context.shouldAbort) return false;\n\t    context.count++;\n\t\n\t    var accessor = context.accessor,\n\t        scoredCandidates = context.scoredCandidates,\n\t        scoreProvider = context.scoreProvider;\n\t\n\t    // Get the string representation of candidate\n\t\n\t    var string = accessor != null ? accessor(candidate) : candidate;\n\t    if (string == null || !string.length) return true;\n\t\n\t    // Get score, If score greater than 0 add to valid results\n\t    var score = scoreProvider.score(string, preparedQuery, options);\n\t    if (score > 0) scoredCandidates.push({ candidate: candidate, score: score });\n\t\n\t    return true;\n\t}\n\t\n\tfunction pluckCandidates(a) {\n\t    return a.candidate;\n\t}\n\t\n\tfunction sortCandidates(a, b) {\n\t    return b.score - a.score;\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar FilterStateInternal = exports.FilterStateInternal = function FilterStateInternal() {\n\t    _classCallCheck(this, FilterStateInternal);\n\t\n\t    this.isActive = false;\n\t    this.shouldAbort = false;\n\t    this.discardResults = false;\n\t    this.count = 0;\n\t    this.scoredCandidates = null;\n\t    this.accessor = null;\n\t    this.scoreProvider = null;\n\t};\n\t\n\tvar FilterState =\n\t\n\t/**\r\n\t * @param {FilterStateInternal} internalState\r\n\t */\n\t\n\texports.FilterState = function FilterState(internalState) {\n\t    _classCallCheck(this, FilterState);\n\t\n\t    // Closure over the internal state to make it read-only.\n\t\n\t    this.abort = function abort() {\n\t        var keepResults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t        internalState.isActive = false;\n\t        internalState.shouldAbort = true;\n\t        internalState.discardResults = !keepResults;\n\t    };\n\t\n\t    this.isActive = function isActive() {\n\t        return internalState.isActive;\n\t    };\n\t\n\t    this.isCanceled = function isCanceled() {\n\t        return internalState.shouldAbort;\n\t    };\n\t\n\t    this.getProgressCount = function getProgressCount() {\n\t        return internalState.count;\n\t    };\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.match = match;\n\texports.wrap = wrap;\n\t\n\tvar _scorer = __webpack_require__(1);\n\t\n\texports.default = {\n\t    match: match,\n\t    wrap: wrap\n\t};\n\t\n\t// Return position of character which matches\n\t\n\t/**\r\n\t *\r\n\t * @param {string} string\r\n\t * @param {Query} preparedQuery\r\n\t * @param {MatchOptions} options\r\n\t * @returns {Array.<number>}\r\n\t */\n\t// A match list is an array of indexes to characters that match.\n\t// This file should closely follow `scorer` except that it returns an array\n\t// of indexes instead of a score.\n\t\n\tfunction match(string, preparedQuery, options) {\n\t    var allowErrors = options.allowErrors,\n\t        pathSeparator = options.pathSeparator;\n\t\n\t\n\t    if (!allowErrors && !(0, _scorer.isMatch)(string, preparedQuery.core_lw, preparedQuery.core_up)) {\n\t        return [];\n\t    }\n\t    var string_lw = string.toLowerCase();\n\t\n\t    // Full path results\n\t    var matches = computeMatch(string, string_lw, preparedQuery);\n\t\n\t    //if there is no matches on the full path, there should not be any on the base path either.\n\t    if (matches.length === 0) {\n\t        return matches;\n\t    }\n\t\n\t    // Is there a base path ?\n\t    if (string.indexOf(pathSeparator) > -1) {\n\t\n\t        // Base path results\n\t        var baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);\n\t\n\t        // Combine the results, removing duplicate indexes\n\t        matches = mergeMatches(matches, baseMatches);\n\t    }\n\t\n\t    return matches;\n\t}\n\t\n\t//\n\t// Wrap\n\t//\n\t// Helper around match if you want a string with result wrapped by some delimiter text\n\t\n\t/**\r\n\t *\r\n\t * @param {string} string\r\n\t * @param {Query} preparedQuery\r\n\t * @param {WrapOptions} options\r\n\t * @returns {*}\r\n\t */\n\tfunction wrap(string, preparedQuery, options) {\n\t\n\t    var tagClass = options.tagClass || 'highlight';\n\t    var tagOpen = options.tagOpen || '<strong class=\"' + tagClass + '\">';\n\t    var tagClose = options.tagClose || '</strong>';\n\t\n\t    if (string === preparedQuery.query) {\n\t        return tagOpen + string + tagClose;\n\t    }\n\t\n\t    //Run get position where a match is found\n\t    var matchPositions = match(string, preparedQuery, options);\n\t    var nbMatches = matchPositions.length;\n\t\n\t    //If no match return as is\n\t    if (nbMatches === 0) {\n\t        return string;\n\t    }\n\t\n\t    //Loop over match positions\n\t    var output = '';\n\t    var matchIndex = -1;\n\t    var strPos = 0;\n\t    while (++matchIndex < nbMatches) {\n\t        var matchPos = matchPositions[matchIndex];\n\t\n\t        // Get text before the current match position\n\t        if (matchPos > strPos) {\n\t            output += string.substring(strPos, matchPos);\n\t            strPos = matchPos;\n\t        }\n\t\n\t        // Get consecutive matches to wrap under a single tag\n\t        while (++matchIndex < nbMatches) {\n\t            if (matchPositions[matchIndex] === matchPos + 1) {\n\t                matchPos++;\n\t            } else {\n\t                matchIndex--;\n\t                break;\n\t            }\n\t        }\n\t\n\t        //Get text inside the match, including current character\n\t        matchPos++;\n\t        if (matchPos > strPos) {\n\t            output += tagOpen;\n\t            output += string.substring(strPos, matchPos);\n\t            output += tagClose;\n\t            strPos = matchPos;\n\t        }\n\t    }\n\t\n\t    //Get string after last match\n\t    if (strPos < string.length - 1) {\n\t        output += string.substring(strPos);\n\t    }\n\t\n\t    //return wrapped text\n\t    return output;\n\t}\n\t\n\tfunction basenameMatch(subject, subject_lw, preparedQuery, pathSeparator) {\n\t\n\t    // Skip trailing slashes\n\t    var end = subject.length - 1;\n\t    while (subject[end] === pathSeparator) {\n\t        end--;\n\t    }\n\t\n\t    // Get position of basePath of subject.\n\t    var basePos = subject.lastIndexOf(pathSeparator, end);\n\t\n\t    //If no PathSeparator, no base path exist.\n\t    if (basePos === -1) {\n\t        return [];\n\t    }\n\t\n\t    // Get the number of folder in query\n\t    var depth = preparedQuery.depth;\n\t\n\t    // Get that many folder from subject\n\t\n\t    while (depth-- > 0) {\n\t        basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n\t        if (basePos === -1) {\n\t            return [];\n\t        }\n\t    } //consumed whole subject ?\n\t\n\t    // Get basePath match\n\t    basePos++;\n\t    end++;\n\t    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);\n\t}\n\t\n\t//\n\t// Combine two matches result and remove duplicate\n\t// (Assume sequences are sorted, matches are sorted by construction.)\n\t//\n\t\n\tfunction mergeMatches(a, b) {\n\t    var m = a.length;\n\t    var n = b.length;\n\t\n\t    if (n === 0) {\n\t        return a.slice();\n\t    }\n\t    if (m === 0) {\n\t        return b.slice();\n\t    }\n\t\n\t    var i = -1;\n\t    var j = 0;\n\t    var bj = b[j];\n\t    var out = [];\n\t\n\t    while (++i < m) {\n\t        var ai = a[i];\n\t\n\t        while (bj <= ai && ++j < n) {\n\t            if (bj < ai) {\n\t                out.push(bj);\n\t            }\n\t            bj = b[j];\n\t        }\n\t\n\t        out.push(ai);\n\t    }\n\t\n\t    while (j < n) {\n\t        out.push(b[j++]);\n\t    }\n\t\n\t    return out;\n\t}\n\t\n\t//----------------------------------------------------------------------\n\t\n\t//\n\t// Align sequence (used for fuzzaldrin.match)\n\t// Return position of subject characters that match query.\n\t//\n\t// Follow closely scorer.computeScore.\n\t// Except at each step we record what triggered the best score.\n\t// Then we trace back to output matched characters.\n\t//\n\t// Differences are:\n\t// - we record the best move at each position in a matrix, and finish by a traceback.\n\t// - we reset consecutive sequence if we do not take the match.\n\t// - no hit miss limit\n\t\n\t\n\tfunction computeMatch(subject, subject_lw, preparedQuery) {\n\t    var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\t    var query = preparedQuery.query;\n\t    var query_lw = preparedQuery.query_lw;\n\t\n\t\n\t    var m = subject.length;\n\t    var n = query.length;\n\t\n\t    //this is like the consecutive bonus, but for camelCase / snake_case initials\n\t    var acro_score = (0, _scorer.scoreAcronyms)(subject, subject_lw, query, query_lw).score;\n\t\n\t    //Init\n\t    var score_row = new Array(n);\n\t    var csc_row = new Array(n);\n\t\n\t    // Directions constants\n\t    var STOP = 0;\n\t    var UP = 1;\n\t    var LEFT = 2;\n\t    var DIAGONAL = 3;\n\t\n\t    //Traceback matrix\n\t    var trace = new Array(m * n);\n\t    var pos = -1;\n\t\n\t    //Fill with 0\n\t    var j = -1; //0..n-1\n\t    while (++j < n) {\n\t        score_row[j] = 0;\n\t        csc_row[j] = 0;\n\t    }\n\t\n\t    var move = void 0;\n\t    var score_diag = void 0;\n\t    var score = void 0;\n\t    var score_up = void 0;\n\t    var csc_diag = void 0;\n\t\n\t    var i = -1; //0..m-1\n\t    while (++i < m) {\n\t        //foreach char si of subject\n\t\n\t        score = 0;\n\t        score_up = 0;\n\t        csc_diag = 0;\n\t\n\t        var si_lw = subject_lw[i];\n\t\n\t        j = -1; //0..n-1\n\t        while (++j < n) {\n\t            //foreach char qj of query\n\t\n\t            //reset score\n\t            var csc_score = 0;\n\t            var align = 0;\n\t            score_diag = score_up;\n\t\n\t            //Compute a tentative match\n\t            if (query_lw[j] === si_lw) {\n\t\n\t                var start = (0, _scorer.isWordStart)(i, subject, subject_lw);\n\t\n\t                // Forward search for a sequence of consecutive char\n\t                csc_score = csc_diag > 0 ? csc_diag : (0, _scorer.scoreConsecutives)(subject, subject_lw, query, query_lw, i, j, start);\n\t\n\t                // Determine bonus for matching A[i] with B[j]\n\t                align = score_diag + (0, _scorer.scoreCharacter)(i, j, start, acro_score, csc_score);\n\t            }\n\t\n\t            //Prepare next sequence & match score.\n\t            score_up = score_row[j]; // Current score_up is next run score diag\n\t            csc_diag = csc_row[j];\n\t\n\t            //In case of equality, moving UP get us closer to the init of the candidate string.\n\t            if (score > score_up) {\n\t                move = LEFT;\n\t            } else {\n\t                score = score_up;\n\t                move = UP;\n\t            }\n\t\n\t            // Only take alignment if it's the absolute best option.\n\t            if (align > score) {\n\t                score = align;\n\t                move = DIAGONAL;\n\t            } else {\n\t                //If we do not take this character, break consecutive sequence.\n\t                // (when consecutive is 0, it'll be recomputed)\n\t                csc_score = 0;\n\t            }\n\t\n\t            score_row[j] = score;\n\t            csc_row[j] = csc_score;\n\t            trace[++pos] = score > 0 ? move : STOP;\n\t        }\n\t    }\n\t\n\t    // -------------------\n\t    // Go back in the trace matrix\n\t    // and collect matches (diagonals)\n\t\n\t    i = m - 1;\n\t    j = n - 1;\n\t    pos = i * n + j;\n\t    var backtrack = true;\n\t    var matches = [];\n\t\n\t    while (backtrack && i >= 0 && j >= 0) {\n\t        switch (trace[pos]) {\n\t            case UP:\n\t                i--;\n\t                pos -= n;\n\t                break;\n\t            case LEFT:\n\t                j--;\n\t                pos--;\n\t                break;\n\t            case DIAGONAL:\n\t                matches.push(i + offset);\n\t                j--;\n\t                i--;\n\t                pos -= n + 1;\n\t                break;\n\t            default:\n\t                backtrack = false;\n\t        }\n\t    }\n\t\n\t    matches.reverse();\n\t    return matches;\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.Query = undefined;\n\t\n\tvar _pathScorer = __webpack_require__(2);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } //\n\t// Query object\n\t//\n\t// Allow to reuse some quantities computed from query.\n\t// Optional char can optionally be specified in the form of a regular expression.\n\t//\n\t\n\t\n\tvar Query = exports.Query = function Query(query, options) {\n\t    _classCallCheck(this, Query);\n\t\n\t    if (query == null || !query.length) {\n\t        return;\n\t    }\n\t\n\t    this.query = query;\n\t    this.query_lw = query.toLowerCase();\n\t    this.core = coreChars(query, options.optCharRegEx);\n\t    this.core_lw = this.core.toLowerCase();\n\t    this.core_up = truncatedUpperCase(this.core);\n\t    this.depth = (0, _pathScorer.countDir)(query, query.length, options.pathSeparator);\n\t    this.ext = (0, _pathScorer.getExtension)(this.query_lw);\n\t    this.charCodes = getCharCodes(this.query_lw);\n\t};\n\t\n\t//\n\t// Optional chars\n\t// Those char improve the score if present, but will not block the match (score=0) if absent.\n\t\n\tvar opt_char_re = /[ _\\-:\\/\\\\]/g;\n\t\n\tfunction coreChars(query, optCharRegEx) {\n\t\n\t    if (optCharRegEx == null) {\n\t        optCharRegEx = opt_char_re;\n\t    }\n\t\n\t    return query.replace(optCharRegEx, '');\n\t}\n\t\n\t//\n\t// Truncated Upper Case:\n\t// --------------------\n\t//\n\t// A fundamental mechanic is that we are able to keep uppercase and lowercase variant of the strings in sync.\n\t// For that we assume uppercase and lowercase version of the string have the same length.\n\t// Of course unicode being unicode there's exceptions.\n\t// See ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt for the list\n\t//\n\t// \"Straße\".toUpperCase() -> \"STRASSE\"\n\t// truncatedUpperCase(\"Straße\") -> \"STRASE\"\n\t// iterating over every character, getting uppercase variant and getting first char of that.\n\t//\n\t\n\tfunction truncatedUpperCase(str) {\n\t    var upper = \"\";\n\t    for (var _iterator = str, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n\t        var _ref;\n\t\n\t        if (_isArray) {\n\t            if (_i >= _iterator.length) break;\n\t            _ref = _iterator[_i++];\n\t        } else {\n\t            _i = _iterator.next();\n\t            if (_i.done) break;\n\t            _ref = _i.value;\n\t        }\n\t\n\t        var char = _ref;\n\t\n\t        upper += char.toUpperCase()[0];\n\t    }\n\t    return upper;\n\t}\n\t\n\t//\n\t// Get character codes:\n\t// --------------------\n\t//\n\t// Get character codes map for a given string\n\t//\n\t\n\tfunction getCharCodes(str) {\n\t    var len = str.length;\n\t    var i = -1;\n\t\n\t    var charCodes = [];\n\t    // create map\n\t    while (++i < len) {\n\t        charCodes[str.charCodeAt(i)] = true;\n\t    }\n\t\n\t    return charCodes;\n\t}\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\texports.isFunction = isFunction;\n\texports.isArray = isArray;\n\texports.getIterator = getIterator;\n\texports.isIteratorItem = isIteratorItem;\n\texports.default = {\n\t    isFunction: isFunction,\n\t    isArray: isArray,\n\t    getIterator: getIterator,\n\t    isIteratorItem: isIteratorItem\n\t};\n\tfunction isFunction(fn) {\n\t    return typeof fn === \"function\";\n\t}\n\t\n\tfunction isArray(tentativeArray) {\n\t\n\t    if (isFunction(Array.isArray)) {\n\t        return Array.isArray(tentativeArray);\n\t    }\n\t\n\t    return Object.prototype.toString.call(tentativeArray) === \"[object Array]\";\n\t}\n\t\n\t//\n\t// Es6 compatible iterator.\n\t// Follow convention of ImmutableJS\n\t//\n\t\n\tvar REAL_ITERATOR_SYMBOL = typeof Symbol === \"function\" && _typeof(Symbol.iterator) === \"symbol\" ? Symbol.iterator : null;\n\tvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\t\n\tfunction getIterator(object) {\n\t\n\t    if (object == null) return null;\n\t\n\t    // Get iterator from Iterable\n\t    var iterator = null;\n\t    if (REAL_ITERATOR_SYMBOL != null && isFunction(object[REAL_ITERATOR_SYMBOL])) {\n\t        // real es6 Iterable\n\t        iterator = object[REAL_ITERATOR_SYMBOL]();\n\t    } else if (isFunction(object[REAL_ITERATOR_SYMBOL])) {\n\t        // es < 6 fallback.\n\t        iterator = object[FAUX_ITERATOR_SYMBOL]();\n\t    }\n\t\n\t    // Ensure that that iterator implements 'next' function\n\t    if (iterator != null && isFunction(iterator.next)) return iterator;\n\t\n\t    // Test if object itself is iterator-like\n\t    if (isFunction(object.next)) {\n\t        return object;\n\t    }\n\t\n\t    return null;\n\t}\n\t\n\tfunction isIteratorItem(item) {\n\t    return item != null && 'done' in item && 'value' in item;\n\t}\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// fuzzaldrin-plus.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 1bf5549ba9fcf7dff3ec","//\n// Score similarity between two string\n//\n//  isMatch: Fast detection if all character of needle is in haystack\n//  score: Find string similarity using a Smith Waterman algorithm\n//         Modified to account for programing scenarios (CamelCase folder/file.ext object.property)\n//\n// Copyright (C) 2015 Jean Christophe Roy and contributors\n// MIT License: http://opensource.org/licenses/MIT\n\n\n// Base point for a single character match\n// This balance making patterns VS position and size penalty.\nconst wm = 150;\n\n//Fading function\nconst pos_bonus = 20; // The character from 0..pos_bonus receive a greater bonus for being at the init of string.\nconst tau_size = 85; // Full path length at which the whole match score is halved.\n\n// Miss count\n// When subject[i] is query[j] we register a hit.\n// Limiting hit put a boundary on how many permutation we consider to find the best one.\n// Helps to speed-up processing of long path and query containing frequent character (eg vowels)\n//\n// If a spec with frequent repetition fail, increase this.\n// This has a direct influence on worst case scenario benchmark.\nconst miss_coeff = 0.75; //Max number missed consecutive hit = ceil(miss_coeff*query.length) + 5\n\n\n//\n// Main export\n//\n\nexport default{\n\n    score,\n    isMatch,\n\n    // Other exports from the is* and score* families are available as named exports.\n    // They are used, amongst other things, to sync scorer and matcher behavior\n\n}\n\n\n// Manage the logic of testing if there's a match and calling the main scoring function\n// Also manage scoring a path and optional character.\n\nexport function score(string, preparedQuery, options) {\n    let {allowErrors} = options;\n    if (!allowErrors && !isMatch(string, preparedQuery.core_lw, preparedQuery.core_up)) {\n        return 0;\n    }\n    let string_lw = string.toLowerCase();\n    let score = computeScore(string, string_lw, preparedQuery, options);\n    return Math.ceil(score);\n}\n\n\n//\n// isMatch:\n// Are all (non optional)characters of query in subject, in proper order ?\n//\n\nexport function isMatch(subject, query_lw, query_up) {\n    let m = subject.length;\n    let n = query_lw.length;\n\n    if (!m || n > m) {\n        return false;\n    }\n\n    let i = -1;\n    let j = -1;\n\n    //foreach char of query\n    while (++j < n) {\n\n        let qj_lw = query_lw.charCodeAt(j);\n        let qj_up = query_up.charCodeAt(j);\n\n        // Continue walking the subject from where we have left with previous query char\n        // until we have found a character that is either lowercase or uppercase query.\n        while (++i < m) {\n            let si = subject.charCodeAt(i);\n            if (si === qj_lw || si === qj_up) {\n                break;\n            }\n        }\n\n        // If we passed the last char, query is not in subject\n        if (i === m) {\n            return false;\n        }\n    }\n\n    // Found every char of query in subject in proper order, match is positive\n    return true;\n}\n\n\n//----------------------------------------------------------------------\n//\n// Main scoring algorithm\n//\n\nexport function computeScore(subject, subject_lw, preparedQuery, options) {\n    let {query, query_lw} = preparedQuery;\n    let flexUppercase = true;\n\n\n    let m = subject.length;\n    let n = query.length;\n    let current_score = 0;\n\n    //----------------------------\n    // Abbreviations sequence\n\n    let acro = scoreAcronyms(subject, subject_lw, query, query_lw);\n    let acro_score = acro.score;\n\n    // Whole query is abbreviation ?\n    // => use that as score\n    if (acro.count === n) {\n        return scoreExact(n, m, acro_score, acro.pos);\n    }\n\n    //----------------------------\n    // Exact Match ?\n    // => use that as score\n\n    let pos = subject_lw.indexOf(query_lw);\n    if (pos > -1) {\n        return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);\n    }\n\n\n    //----------------------------\n    // Individual characters\n    // (Smith Waterman algorithm)\n\n\n    //Init\n    let score_row = new Array(n);\n    let csc_row = new Array(n);\n    let sz = scoreSize(n, m);\n\n    let miss_budget = Math.ceil(miss_coeff * n) + 5;\n    let miss_left = miss_budget;\n\n    //Fill with 0\n    let j = -1;\n    while (++j < n) {\n        score_row[j] = 0;\n        csc_row[j] = 0;\n    }\n\n    // Limit the search to the isActive region\n    // for example with query `abc`, subject `____a_bc_ac_c____`\n    // there's a region before first `a` and after last `c`\n    // that can be simplified out of the matching process\n\n    // Before first occurrence in subject of first letter of query, or -1\n    let i = subject_lw.indexOf(query_lw[0]);\n    if (i > -1) {\n        i--;\n    }\n\n    // After last occurrence of last letter of query,\n    let mm = subject_lw.lastIndexOf(query_lw[n - 1], m);\n    if (mm > i) {\n        m = mm + 1;\n    }\n\n    let csc_invalid = true;\n\n    while (++i < m) {     //foreach char si of subject\n\n        let si_lw = subject_lw[i];\n\n        // if si_lw is not in query\n        if (preparedQuery.charCodes[si_lw.charCodeAt(0)] == null) {\n            // reset csc_row and move to next\n            if (csc_invalid !== true) {\n                j = -1;\n                while (++j < n) {\n                    csc_row[j] = 0;\n                }\n                csc_invalid = true;\n            }\n            continue;\n        }\n\n        let si = subject_lw[i];\n\n        current_score = 0;\n        let score_diag = 0;\n        let csc_diag = 0;\n        let record_miss = true;\n        csc_invalid = false;\n\n        j = -1; //0..n-1\n        while (++j < n) {   //foreach char qj of query\n\n            // What is the best gap ?\n            // score_up contain the score of a gap in subject.\n            // score_left = last iteration of score, -> gap in query.\n            let score_up = score_row[j];\n            if (score_up > current_score) {\n                current_score = score_up;\n            }\n\n            //Reset consecutive\n            let csc_score = 0;\n            let qj_lw = query_lw[j];\n\n\n            // Compute a tentative match\n            // First check case-insesitive match\n            if (qj_lw === si_lw ) {\n\n                // Refine for strict Uppercase\n                //\n                // When do we have a match ?\n                // A) Case Insensitive Match && Not strict Uppercase\n                // B) Case Insensitive Match && Query is lowercase\n                // C) Case Sensitive Match. (Imply Case Insensitive)\n\n                let qj = query[j];\n                if(flexUppercase || qj_lw === qj || si === qj){\n\n                    let start = isWordStart(i, subject, subject_lw);\n\n                    // Forward search for a sequence of consecutive char\n                    csc_score = csc_diag > 0 ? csc_diag :\n                        scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n\n                    // Determine bonus for matching A[i] with B[j]\n                    let align_score = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n\n                    //Are we better using this match or taking the best gap (currently stored in score)?\n                    if (align_score > current_score) {\n                        current_score = align_score;\n                        // reset consecutive missed hit count\n                        miss_left = miss_budget;\n                    } else {\n                        // We rejected this match and record a miss.\n                        // If budget is exhausted exit\n                        if (record_miss && --miss_left <= 0) {\n                            return score_row[n - 1] * sz;\n                        }\n                        record_miss = false;\n                    }\n                }\n            }\n\n\n            //Prepare next sequence & match score.\n            score_diag = score_up;\n            csc_diag = csc_row[j];\n            csc_row[j] = csc_score;\n            score_row[j] = current_score;\n        }\n    }\n\n    // get highest score so far\n    current_score = score_row[n - 1];\n    return current_score * sz;\n\n}\n\n//\n// Boundaries\n//\n// Is the character at the init of a word, end of the word, or a separator ?\n// Fortunately those small function inline well.\n//\n\nexport function isWordStart(pos, subject, subject_lw) {\n    if (pos === 0) {\n        return true;\n    } // match is FIRST char ( place a virtual token separator before first char of string)\n    let curr_s = subject[pos];\n    let prev_s = subject[pos - 1];\n    return isSeparator(prev_s) || // match FOLLOW a separator\n        (  curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1] ); // match is Capital in camelCase (preceded by lowercase)\n}\n\n\nexport function isWordEnd(pos, subject, subject_lw, len) {\n    if (pos === len - 1) {\n        return true;\n    } // last char of string\n    let curr_s = subject[pos];\n    let next_s = subject[pos + 1];\n    return isSeparator(next_s) || // match IS FOLLOWED BY a separator\n        ( curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1] ); // match is lowercase, followed by uppercase\n}\n\nexport function isSeparator(c) {\n    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\\\';\n}\n//\n// Scoring helper\n//\n\nexport function scorePosition(pos) {\n    if (pos < pos_bonus) {\n        let sc = pos_bonus - pos;\n        return 100 + (sc * sc);\n    } else {\n        return Math.max((100 + pos_bonus) - pos, 0);\n    }\n}\n\nexport function scoreSize(n, m) {\n    // Size penalty, use the difference of size (m-n)\n    return tau_size / ( tau_size + Math.abs(m - n))\n}\n\nexport function scoreExact(n, m, quality, pos) {\n    return 2 * n * ( (wm * quality) + scorePosition(pos) ) * scoreSize(n, m);\n}\n\n\n//\n// Shared scoring logic between exact match, consecutive & acronym\n// Ensure pattern length dominate the score then refine to take into account case-sensitivity\n// and structural quality of the pattern on the overall string (word boundary)\n//\n\nexport function scorePattern(count, len, sameCase, start, end) {\n    let sz = count;\n\n    let bonus = 6; // to ensure consecutive length dominate score, this should be as large other bonus combined\n    if (sameCase === count) {\n        bonus += 2;\n    }\n    if (start) {\n        bonus += 3;\n    }\n    if (end) {\n        bonus += 1;\n    }\n\n    if (count === len) {\n        // when we match 100% of query we allow to break the size ordering.\n        // This is to help exact match bubble up vs size, depth penalty etc\n        if (start) {\n            if (sameCase === len) {\n                sz += 2;\n            } else {\n                sz += 1;\n            }\n        }\n        if (end) {\n            bonus += 1;\n        }\n    }\n\n    return sameCase + (sz * ( sz + bonus ));\n}\n\n\n//\n// Compute the bonuses for two chars that are confirmed to matches in a case-insensitive way\n//\n\nexport function scoreCharacter(i, j, start, acro_score, csc_score) {\n\n    // init of string / position of match bonus\n    let posBonus = scorePosition(i);\n\n    // match IS a word boundary\n    // choose between taking part of consecutive characters or consecutive acronym\n    if (start) {\n        return posBonus + (wm * ( (acro_score > csc_score ? acro_score : csc_score) + 10  ));\n    }\n\n    // normal Match\n    return posBonus + (wm * csc_score);\n}\n\n\n//\n// Forward search for a sequence of consecutive character.\n//\n\nexport function scoreConsecutives(subject, subject_lw, query, query_lw, i, j, startOfWord) {\n    let m = subject.length;\n    let n = query.length;\n\n    let mi = m - i;\n    let nj = n - j;\n    let k = mi < nj ? mi : nj;\n\n    let sameCase = 0;\n\n    // query_lw[i] is subject_lw[j] has been checked before entering now do case sensitive check.\n    if (query[j] === subject[i]) {\n        sameCase++;\n    }\n\n    // size of consecutive\n    // sz will be one more than the last index where query[j] == subject[i] (lowercase)\n    let sz = 0;\n\n    //Continue while lowercase char are the same, record when they are case-sensitive match.\n    while (++sz < k && query_lw[++j] === subject_lw[++i]) {\n        if (query[j] === subject[i]) {\n            sameCase++;\n        }\n    }\n\n    // Faster path for single match.\n    // Isolated character match occurs often and are not really interesting.\n    // Fast path so we don't compute expensive pattern score on them.\n    // Acronym should be addressed with acronym context bonus instead of consecutive.\n    if (sz === 1) {\n        return 1 + (2 * sameCase);\n    }\n\n    return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));\n}\n\n\n//\n// Compute the score of an exact match at position pos.\n//\n\nexport function scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m) {\n\n    // Test for word init\n    let start = isWordStart(pos, subject, subject_lw);\n\n    // Heuristic\n    // If not a word init, test next occurrence\n    // - We want exact match to be fast\n    // - For exact match, word init has the biggest impact on score.\n    // - Testing 2 instances is somewhere between testing only one and testing every instances.\n\n    if (!start) {\n        let pos2 = subject_lw.indexOf(query_lw, pos + 1);\n        if (pos2 > -1) {\n            start = isWordStart(pos2, subject, subject_lw);\n            if (start) {\n                pos = pos2;\n            }\n        }\n    }\n\n    //Exact case bonus.\n    let i = -1;\n    let sameCase = 0;\n    while (++i < n) {\n        if (query[pos + i] === subject[i]) {\n            sameCase++;\n        }\n    }\n\n    let end = isWordEnd((pos + n) - 1, subject, subject_lw, m);\n\n    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);\n}\n\n\n//\n// Acronym prefix\n//\n\n\nclass AcronymResult {\n    constructor(score, pos, count) {\n        this.score = score;\n        this.pos = pos;\n        this.count = count;\n    }\n}\n\nlet emptyAcronymResult = new AcronymResult(0, 0.1, 0);\n\nexport function scoreAcronyms(subject, subject_lw, query, query_lw) {\n    let m = subject.length;\n    let n = query.length;\n\n    //a single char is not an acronym\n    if (m <= 1 || n <= 1) {\n        return emptyAcronymResult;\n    }\n\n    let count = 0;\n    let sepCount = 0;\n    let sumPos = 0;\n    let sameCase = 0;\n\n    let i = -1;\n    let j = -1;\n\n    //foreach char of query\n    while (++j < n) {\n\n        let qj_lw = query_lw[j];\n\n        // Separator will not score point but will continue the prefix when present.\n        // Test that the separator is in the candidate and advance cursor to that position.\n        // If no separator break the prefix\n\n        if (isSeparator(qj_lw)) {\n            i = subject_lw.indexOf(qj_lw, i + 1);\n            if (i > -1) {\n                sepCount++;\n                continue;\n            } else {\n                break;\n            }\n        }\n\n        // For other characters we search for the first match where subject[i] = query[j]\n        // that also happens to be a init-of-word\n\n        while (++i < m) {\n            if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {\n                if (query[j] === subject[i]) {\n                    sameCase++;\n                }\n                sumPos += i;\n                count++;\n                break;\n            }\n        }\n\n        // All of subject is consumed, stop processing the query.\n        if (i === m) {\n            break;\n        }\n    }\n\n\n    // Here, all of query is consumed (or we have reached a character not in acronym)\n    // A single character is not an acronym (also prevent division by 0)\n    if (count < 2) {\n        return emptyAcronymResult;\n    }\n\n    // Acronym are scored as init-of-word\n    // Unless the acronym is a 1:1 match with candidate then it is upgraded to full-word.\n    let fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;\n    let score = scorePattern(count, n, sameCase, true, fullWord);\n\n    return new AcronymResult(score, sumPos / count, count + sepCount);\n}\n\n\n//\n// Test whether there's a 1:1 relationship between query and acronym of candidate.\n// For that to happens\n// (a) All character of query must be matched to an acronym of candidate\n// (b) All acronym of candidate must be matched to a character of query.\n//\n// This method check for (b) assuming (a) has been checked before entering.\n\nfunction isAcronymFullWord(subject, subject_lw, query, nbAcronymInQuery) {\n    let m = subject.length;\n    let n = query.length;\n    let count = 0;\n\n    // Heuristic:\n    // Assume one acronym every (at most) 12 character on average\n    // This filter out long paths, but then they can match on the filename.\n    if (m > 12 * n) {\n        return false;\n    }\n\n    let i = -1;\n    while (++i < m) {\n        //For each char of subject\n        //Test if we have an acronym, if so increase acronym count.\n        //If the acronym count is more than nbAcronymInQuery (number of non separator char in query)\n        //Then we do not have 1:1 relationship.\n        if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/scorer.js","import {isMatch, computeScore, scoreSize} from \"./scorer\";\r\n\r\n\r\nconst tau_depth = 13; //  Directory depth at which the full path influence is halved.\r\nconst file_coeff = 1.2; //  Full path is also penalized for length of basename. This adjust a scale factor for that penalty.\r\n\r\nexport default{\r\n    score,\r\n    countDir,\r\n    getExtensionScore\r\n}\r\n\r\n//  Manage the logic of testing if there's a match and calling the main scoring function\r\n//  Also manage scoring a path and optional character.\r\n\r\nexport function score(string, preparedQuery, options) {\r\n    let {allowErrors} = options;\r\n    if (!allowErrors && !isMatch(string, preparedQuery.core_lw, preparedQuery.core_up)) {\r\n        return 0;\r\n    }\r\n    let string_lw = string.toLowerCase();\r\n    let score = computeScore(string, string_lw, preparedQuery, options);\r\n    score = scorePath(string, string_lw, score, preparedQuery, options);\r\n    return Math.ceil(score);\r\n}\r\n\r\n\r\n// \r\n//  Score adjustment for path\r\n// \r\n\r\nfunction scorePath(subject, subject_lw, fullPathScore, preparedQuery, options) {\r\n\r\n    if (fullPathScore === 0) {\r\n        return 0;\r\n    }\r\n\r\n    let {useExtensionBonus, pathSeparator} = options;\r\n\r\n    //  Skip trailing slashes\r\n    let end = subject.length - 1;\r\n    while (subject[end] === pathSeparator) {\r\n        end--;\r\n    }\r\n\r\n    //  Get position of basePath of subject.\r\n    let basePos = subject.lastIndexOf(pathSeparator, end);\r\n    let fileLength = end - basePos;\r\n\r\n    //  Get a bonus for matching extension\r\n    let extAdjust = 1.0;\r\n\r\n    if (useExtensionBonus) {\r\n        extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);\r\n        fullPathScore *= extAdjust;\r\n    }\r\n\r\n    //  no basePath, nothing else to compute.\r\n    if (basePos === -1) {\r\n        return fullPathScore;\r\n    }\r\n\r\n    //  Get the number of folder in query\r\n    let {depth} = preparedQuery;\r\n\r\n    //  Get that many folder from subject\r\n    while (basePos > -1 && depth-- > 0) {\r\n        basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\r\n    }\r\n\r\n    //  Get basePath score, if BaseName is the whole string, no need to recompute\r\n    //  We still need to apply the folder depth and filename penalty.\r\n    let basePathScore = (basePos === -1) ? fullPathScore :\r\n    extAdjust * computeScore(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), preparedQuery, options);\r\n\r\n    //  Final score is linear interpolation between base score and full path score.\r\n    //  For low directory depth, interpolation favor base Path then include more of full path as depth increase\r\n    //\r\n    //  A penalty based on the size of the basePath is applied to fullPathScore\r\n    //  That way, more focused basePath match can overcome longer directory path.\r\n\r\n    let alpha = (0.5 * tau_depth) / ( tau_depth + countDir(subject, end + 1, pathSeparator) );\r\n    return (alpha * basePathScore) + ((1 - alpha) * fullPathScore * scoreSize(0, file_coeff * (fileLength)));\r\n}\r\n\r\n\r\n// \r\n//  Count number of folder in a path.\r\n//  (consecutive slashes count as a single directory)\r\n// \r\n\r\nexport function countDir(path, end, pathSeparator) {\r\n    if (end < 1) {\r\n        return 0;\r\n    }\r\n\r\n    let count = 0;\r\n    let i = 0;\r\n\r\n    // skip slash at the start of string\r\n    // so `foo/bar` and `/foo/bar` have the same depth.\r\n    while (i < end && path[i] === pathSeparator){\r\n        i++;\r\n    }\r\n\r\n    // scan for path separator\r\n    while (i < end) {\r\n\r\n        if (path[i] === pathSeparator) {\r\n\r\n            //When path found increase directory depth\r\n            count++;\r\n\r\n            //But treat multiple consecutive pathSeparator as one\r\n            while (i < end && path[i] === pathSeparator) {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        i++;\r\n\r\n    }\r\n\r\n    return count;\r\n}\r\n\r\n// \r\n//  Find fraction of extension that is matched by query.\r\n//  For example mf.h prefers myFile.h to myfile.html\r\n//  This need special handling because it give point for not having characters (the `tml` in above example)\r\n// \r\n\r\nexport function getExtension(str) {\r\n    let pos = str.lastIndexOf(\".\");\r\n    if (pos < 0) {\r\n        return \"\";\r\n    } else {\r\n        return str.substr(pos + 1);\r\n    }\r\n}\r\n\r\n\r\nexport function getExtensionScore(candidate, ext, startPos, endPos, maxDepth) {\r\n    //  startPos is the position of last slash of candidate, -1 if absent.\r\n\r\n    if (ext == null || !ext.length) {\r\n        return 0;\r\n    }\r\n\r\n    //  Check that (a) extension exist, (b) it is after the init of the basename\r\n    let pos = candidate.lastIndexOf(\".\", endPos);\r\n    if (pos <= startPos) {\r\n        return 0;\r\n    } //  (note that startPos >= -1)\r\n\r\n    let n = ext.length;\r\n    let m = endPos - pos;\r\n\r\n    //  n contain the smallest of both extension length, m the largest.\r\n    if (m < n) {\r\n        n = m;\r\n        m = ext.length;\r\n    }\r\n\r\n    // place cursor after dot & count number of matching characters in extension\r\n    pos++;\r\n    let matched = -1;\r\n    while (++matched < n) {\r\n        if (candidate[pos + matched] !== ext[matched]) {\r\n            break;\r\n        }\r\n    }\r\n\r\n    //  if nothing found, try deeper for multiple extensions, with some penalty for depth\r\n    if (matched === 0 && maxDepth > 0) {\r\n        return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);\r\n    }\r\n\r\n    //  cannot divide by zero because m is the largest extension length and we return if either is 0\r\n    return matched / m;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/pathScorer.js","import {filterSync as processFilterSync, filterAsync as processFilterAsync} from \"./lib/filter\";\r\nimport {score as processScore} from \"./lib/scorer\";\r\nimport {score as processPathScore} from \"./lib/pathScorer\";\r\nimport {match as processMatch, wrap as processWrap} from \"./lib/matcher\";\r\nimport {Query} from \"./lib/query\";\r\n\r\nconst fuzzaldrin = {\r\n    filter,\r\n    score,\r\n    match,\r\n    wrap,\r\n    prepareQuery,\r\n};\r\n\r\nexport default fuzzaldrin\r\n\r\nlet preparedQueryCache = null;\r\n\r\n/**\r\n * Filter:\r\n *  Given a list of candidate, output a list of candidate that match query.\r\n *  Output list is the same format (string or object) than input list.\r\n *\r\n *  If given a list of object, specify options.key as the property `candidate[key]`\r\n *  that contain the string representation of the candidate\r\n *\r\n *  Output is sorted by match score.\r\n *\r\n * @param {Array.<(string|object)>|Iterable} candidates - array of string or objects\r\n * @param {string} query - string to search for in each candidate\r\n * @param {FilterOptions=} options - (optional) see option hash doc\r\n * @returns {Array.<(string|object)>} - filtered & sorted subset of input candidates\r\n */\r\n\r\nexport function filter(candidates, query, options) {\r\n\r\n    if (!checkString(query)) return [];\r\n    if (!checkCollection(candidates)) return [];\r\n\r\n    options = parseOptions(options);\r\n    let preparedQuery = getPreparedQuery(query, options);\r\n\r\n    return processFilterSync(candidates, preparedQuery, options);\r\n\r\n}\r\n\r\n/**\r\n *\r\n * @param candidates\r\n * @param query\r\n * @param options\r\n * @param {filterCallback} callback\r\n * @returns {FilterState}\r\n */\r\n\r\nexport function filterAsync(candidates, query, callback, options) {\r\n\r\n    if (!checkString(query)) return [];\r\n    if (!checkCollection(candidates)) return [];\r\n\r\n    options = parseOptions(options);\r\n    let preparedQuery = getPreparedQuery(query, options);\r\n\r\n    return processFilterAsync(candidates, preparedQuery, callback, options);\r\n\r\n}\r\n\r\n/**\r\n * Score:\r\n *   Give the numerical score on how a given string match query.\r\n *\r\n *   This is provided so you can build your own filter method.\r\n *   For example you may have a special way to iterate candidate,\r\n *   access candidate string representation, or you may need to\r\n *   modify the score to account external knowledge (eg last modified date)\r\n *\r\n * @param {string} string - string representation of a candidate\r\n * @param {string} query - string to search for in candidate\r\n * @param {ScoringOptions=} options - (optional) see option hash doc\r\n * @returns {number} score 0 .. max, where max is score(string, string)\r\n */\r\n\r\nexport function score(string, query, options) {\r\n\r\n    if (!checkString(string)) return 0;\r\n    if (!checkString(query)) return 0;\r\n\r\n    options = parseOptions(options);\r\n    let preparedQuery = getPreparedQuery(query, options);\r\n\r\n    if (options.usePathScoring) {\r\n        return processPathScore(string, preparedQuery, options);\r\n    } else {\r\n        return processScore(string, preparedQuery, options);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Match:\r\n *    Communicate which characters of candidate where selected by the algorithm to represent the query.\r\n *    The match function output an array of character position.\r\n *    If you need to display those character as an html string see wrap function.\r\n *\r\n * @param {string} string - string representation of a candidate\r\n * @param {string} query - string to search for in candidate\r\n * @param {MatchOptions=} options (optional)\r\n * @returns {Array.<number>}\r\n */\r\n\r\nexport function match(string, query, options) {\r\n\r\n    if (!checkString(string)) return [];\r\n    if (!checkString(query)) return [];\r\n\r\n    //If both are the same, return an array of consecutive numbers\r\n    if (string === query) {\r\n        let length = string.length;\r\n        let range = new Array(length);\r\n        for (let idx = 0; idx < length; idx++) {\r\n            range[idx] = idx;\r\n        }\r\n        return range;\r\n    }\r\n\r\n    options = parseOptions(options);\r\n    let preparedQuery = getPreparedQuery(query, options);\r\n\r\n    return processMatch(string, preparedQuery, options);\r\n}\r\n\r\n\r\n/**\r\n * Wrap:\r\n *    Communicate which characters of candidate where selected by the algorithm to represent the query.\r\n *    This function output the given string with chosen character wrapped in a delimiter string (eg html tag).\r\n *\r\n *    To control the wrap use the option hash.\r\n *    Here are some default value:\r\n *      options.tagOpen = `<strong class=\"highlight\">`\r\n *      options.tagClose = `</strong>`\r\n *\r\n *    Alternatively, if you chose to keep the default tagOpen,\r\n *    you can specify option.tagClass and change the `highlight`\r\n *    class to one of your choosing.\r\n *\r\n *    Wrap method will try to group consecutive matches under the same tag.\r\n *\r\n * @param {string} string - string representation of a candidate\r\n * @param {string} query - string to search for in candidate\r\n * @param {WrapOptions=} options\r\n * @returns {string} - input string with match wrapped in open and close tag.\r\n */\r\n\r\nexport function wrap(string, query, options) {\r\n\r\n    if (!checkString(string)) return \"\";\r\n    if (!checkString(query)) return string;\r\n\r\n    options = parseOptions(options);\r\n    let preparedQuery = getPreparedQuery(query, options);\r\n\r\n    return processWrap(string, query, options);\r\n\r\n}\r\n\r\n/**\r\n * PrepareQuery:\r\n *   The usual scenario is to compare a single query with multiple candidate.\r\n *   To speed that process up, we pre-compute some information about the query.\r\n *\r\n *   Pre-computed query is natural to use in bulk method like filter, but harder\r\n *   in one-by-one method like score or match. To keep those method fast you can give\r\n *   a pre computed query in option hash as `options.preparedQuery`\r\n *\r\n *   Note that we use an internal cache `preparedQueryCache` that cover most of the simple cases\r\n *   So this method may not be needed in thos cases.\r\n *\r\n * @param {string} query\r\n * @param {QueryOptions} options\r\n * @returns {Query}\r\n */\r\n\r\nexport function prepareQuery(query, options) {\r\n    options = parseOptions(options);\r\n    return getPreparedQuery(query, options);\r\n}\r\n\r\n\r\nfunction checkString(str){\r\n    //Not null, must have length property > 0\r\n    return str != null && str.length != null && str.length > 0;\r\n}\r\n\r\nfunction checkCollection(obj){\r\n    // Not null\r\n    // If object has length or size property, must be != 0\r\n    // Example of thing with size: (es6 sets, ImmutableJs collections)\r\n    return obj != null && obj.length !== 0 && obj.size !== 0\r\n}\r\n\r\n\r\n//\r\n// Detect node.js or browser to set default path separator\r\n//\r\n\r\nlet defaultPathSeparator = \"/\";\r\n\r\nif (typeof process === 'object' && Object.prototype.toString.call(process) === '[object process]') {\r\n\r\n    // On node js we assume the list of candidates match local OS path format.\r\n    // See comment bellow to change behavior.\r\n    defaultPathSeparator = (process.platform === \"win32\") ? '\\\\' : '/';\r\n\r\n} else if (typeof window === 'object' && Object.prototype.toString.call(window) === \"[object Window]\") {\r\n\r\n    // We assume that browser are dealing with url, if assumption is false use option hash like so:\r\n    // fuzzaldrin.filter( candidates, query, {pathSeparator: platformSep} )\r\n    // and determine `platformSep` any so it match the format of candidates.\r\n\r\n    defaultPathSeparator = \"/\";\r\n\r\n    // Export main object to global window.\r\n    window.fuzzaldrin = fuzzaldrin;\r\n\r\n}\r\n\r\n//\r\n// Setup default values\r\n//\r\n\r\n/**\r\n * @type {ScoringOptions}\r\n */\r\nlet defaultOptions = {\r\n    allowErrors: false,\r\n    usePathScoring: true,\r\n    useExtensionBonus: false,\r\n    pathSeparator: defaultPathSeparator,\r\n    optCharRegEx: null,\r\n    preparedQuery: null,\r\n};\r\n\r\n\r\n/**\r\n *\r\n * @param {(ScoringOptions|FilterOptions|MatchOptions|WrapOptions)} options\r\n * @returns {(ScoringOptions|FilterOptions|MatchOptions|WrapOptions)} options completed with default values from ScoringOptions\r\n */\r\n\r\nfunction parseOptions(options) {\r\n\r\n    // If no options given, copy default\r\n    // Else merge options with defaults.\r\n\r\n    if(options == null) options = {};\r\n\r\n    let hasOwnProperty = Object.prototype.hasOwnProperty;\r\n    for(let key in defaultOptions){\r\n        if(hasOwnProperty.call(defaultOptions,key) && !hasOwnProperty.call(options,key) ){\r\n            options[key] = defaultOptions[key];\r\n        }\r\n    }\r\n\r\n    return options;\r\n}\r\n\r\nfunction getPreparedQuery(query, options){\r\n\r\n    // If prepared query in option hash is valid, use it\r\n    if(options.preparedQuery != null && options.preparedQuery.query === query)\r\n        return options.preparedQuery;\r\n\r\n    // Recompute cache if empty or invalid\r\n    if (preparedQueryCache == null || preparedQueryCache.query !== query) {\r\n        preparedQueryCache = new Query(query, options)\r\n    }\r\n\r\n    // Serve from cache\r\n    return preparedQueryCache;\r\n\r\n}\r\n\r\n\r\n//\r\n// Documentation for option hash\r\n//\r\n\r\n/**\r\n * @typedef {Object} QueryOptions\r\n * @property {string} pathSeparator - If candidate are path, indicate path separator used (usually '/' or '\\\\').\r\n * @property {RegExp} optCharRegEx - Regex that identify character that does not have to match exactly, for example <whitespace>.\r\n *\r\n */\r\n\r\n/**\r\n * @typedef {Object} ScoringOptions\r\n * @extends QueryOptions\r\n *\r\n * @property {boolean} allowErrors - Should we allow candidates that does not have all characters of query ?\r\n * @property {boolean} usePathScoring - Should we try to interpret candidates as path\r\n * @property {boolean} useExtensionBonus - Should we try to interpret extension from query\r\n *                                         and prefer files that match that extension (needs usePathScoring)\r\n * @property {Query} preparedQuery - If you have a precomputed query object set it here.\r\n */\r\n\r\n\r\n/**\r\n * @typedef {Object} FilterOptions\r\n * @extends ScoringOptions\r\n *\r\n * @property {string|function} key - Name of the property that contain string ot be scored\r\n *                                   or function that input candidate and output string to be scored.\r\n *\r\n * @property {number} maxResults - Output the top `maxResults` best results at most.\r\n * @property {bool} outputScore - If true output is an array of {candidate,score} else output is an array of candidates\r\n *\r\n */\r\n\r\n/**\r\n * @typedef {Object} MatchOptions\r\n * @extends ScoringOptions\r\n *\r\n *\r\n */\r\n\r\n/**\r\n * @typedef {Object} WrapOptions\r\n * @extends MatchOptions\r\n *\r\n * @property {string} tagOpen - string to place before a match default to `<strong class=\"highlight\">`\r\n * @property {string} tagClose - string to place after a match default to `</strong>`\r\n * @property {string} tagClass - change the class of the default open tag (tagOpen must be unset)\r\n *\r\n */\r\n\r\n\r\n//\r\n// Async\r\n//\r\n\r\n/**\r\n * @callback filterCallback\r\n * @param {Array} results\r\n * @param {FilterState} state\r\n */\r\n\r\n/**\r\n * @typedef {Object} FilterState\r\n *\r\n * @method  abort - stop scoring and return no results.\r\n * @method  isActive - is the filter running.\r\n * @method  isCanceled - has the filter been canceled.\r\n * @method  getProgressCount - get the count of processed elements.\r\n *\r\n */\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/fuzzaldrin-plus.js","import scorer from \"./scorer\";\r\nimport pathScorer from \"./pathScorer\";\r\nimport utils from \"./utils\";\r\nimport {FilterState, FilterStateInternal} from './filterState'\r\n\r\n\r\nexport default {\r\n    filterSync,\r\n    filterAsync\r\n};\r\n\r\n/**\r\n *\r\n * @param {Array|Iterable} candidates\r\n * @param {Query} preparedQuery\r\n * @param {FilterOptions} options\r\n * @returns {Array}\r\n */\r\n\r\nexport function filterSync(candidates, preparedQuery,  options) {\r\n    let state = new FilterStateInternal();\r\n    return executeFilter(candidates, preparedQuery, state, options)\r\n}\r\n\r\n/**\r\n *\r\n * @param {Array|Iterable} candidates\r\n * @param {Query} preparedQuery\r\n * @param {FilterOptions} options\r\n * @param {filterCallback} callback\r\n * @returns {FilterState}\r\n */\r\n\r\n\r\nexport function filterAsync(candidates, preparedQuery,  callback, options) {\r\n\r\n    let internalState = new FilterStateInternal();\r\n    let publicState = new FilterState(internalState);\r\n\r\n    let scheduled = () => {\r\n        callback( executeFilter(candidates, preparedQuery, internalState, options), publicState );\r\n    };\r\n\r\n    if(typeof setImmediate === \"function\"){\r\n        setImmediate(scheduled)\r\n    }else{\r\n        setTimeout(scheduled,0)\r\n    }\r\n\r\n    return publicState;\r\n\r\n}\r\n\r\n/**\r\n *\r\n * @param {Array|Iterable} candidates\r\n * @param {Query} preparedQuery\r\n * @param {FilterStateInternal} state\r\n * @param {FilterOptions} options\r\n * @returns {Array}\r\n */\r\n\r\nfunction executeFilter(candidates, preparedQuery, state, options) {\r\n\r\n    if(state.shouldAbort) return [];\r\n\r\n    // See option parsing on main module for default\r\n    const {key, maxResults, outputScore, usePathScoring} = options;\r\n\r\n    // If list of object, we need to get the string to be scored, as defined by options.key\r\n    // If the key is a method, that method should take an object and return the string.\r\n    // Else we assume it is the name of a property on candidate object.\r\n    let accessor = null;\r\n    if(key != null){\r\n        accessor =  utils.isFunction(options.key) ? options.key : (x) => x[key]\r\n    }\r\n\r\n    // Init state\r\n    state.isActive = true;\r\n    state.accessor = accessor;\r\n    state.scoreProvider = usePathScoring ? pathScorer : scorer;\r\n    state.scoredCandidates = [];\r\n\r\n    // Iterate candidate list and collect scored positive matches.\r\n    processCollection(candidates, preparedQuery, state, options);\r\n\r\n    // Collect positives matches\r\n    let scoredCandidates = state.scoredCandidates;\r\n\r\n    // Cleanup\r\n    state.scoredCandidates = null;\r\n    state.isActive = false;\r\n\r\n    // Quick exit\r\n    if(state.discardResults || scoredCandidates==null || !scoredCandidates.length ) return [];\r\n\r\n    // Sort scores in descending order\r\n    scoredCandidates.sort(sortCandidates);\r\n\r\n    // Trim to maxResults if specified\r\n    if (maxResults != null) {\r\n        scoredCandidates = scoredCandidates.slice(0, maxResults);\r\n    }\r\n\r\n    // Return either a sorted list of candidate or list of candidate-score pairs.\r\n    if(outputScore === true){\r\n        return scoredCandidates;\r\n    }else{\r\n        // Extract original candidate and return\r\n        return scoredCandidates.map(pluckCandidates);\r\n    }\r\n\r\n}\r\n\r\nfunction processCollection(collection, preparedQuery, state, options){\r\n\r\n    //\r\n    // Collection is an array\r\n    //\r\n\r\n    if( utils.isArray(collection) ){\r\n        for(let i = 0; i<= collection.length; i++){\r\n            if( !processItem( collection[i], preparedQuery, state, options) ) break;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //\r\n    // Collection is an Iterable or Iterator (es6 protocol)\r\n    //\r\n\r\n    let iterator = utils.getIterator(collection);\r\n    if(iterator != null){\r\n        let item = iterator.next();\r\n        if(utils.isIteratorItem(item)){\r\n            while(!item.done){\r\n                if( !processItem( item.value, preparedQuery, state, options) ) break;\r\n                item = iterator.next()\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n    //\r\n    // Collection implements 'forEach'\r\n    //\r\n\r\n    // Some implementations  of foreach allow to exit using return false. (Eg Immutablejs)\r\n    //      processItem follow that convention .\r\n    //\r\n    // Others cannot be interrupted ( Eg default Array.forEach )\r\n    //      so we continue iteration but short circuit most of the work.\r\n\r\n    let cont = true;\r\n    if( utils.isFunction(collection.forEach) ) {\r\n        collection.forEach((item) => cont = cont && processItem(item, preparedQuery, state, options));\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n *\r\n * @param {string|object} candidate\r\n * @param {Query} preparedQuery\r\n * @param {FilterStateInternal} context\r\n * @param {FilterOptions} options\r\n * @returns {boolean}\r\n */\r\n\r\nfunction processItem(candidate, preparedQuery, context, options){\r\n\r\n    if(context.shouldAbort) return false;\r\n    context.count++;\r\n\r\n    let {accessor, scoredCandidates, scoreProvider } = context;\r\n\r\n    // Get the string representation of candidate\r\n    let string = accessor != null ? accessor(candidate) : candidate;\r\n    if (string == null || !string.length) return true;\r\n\r\n    // Get score, If score greater than 0 add to valid results\r\n    let score = scoreProvider.score(string, preparedQuery, options);\r\n    if (score > 0) scoredCandidates.push({candidate, score});\r\n\r\n    return true;\r\n\r\n}\r\n\r\n\r\nfunction pluckCandidates(a) {\r\n    return a.candidate;\r\n}\r\n\r\nfunction sortCandidates(a, b) {\r\n    return b.score - a.score;\r\n}\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/filter.js","export class FilterStateInternal {\r\n\r\n    constructor() {\r\n        this.isActive = false;\r\n        this.shouldAbort = false;\r\n        this.discardResults = false;\r\n        this.count = 0;\r\n        this.scoredCandidates = null;\r\n        this.accessor = null;\r\n        this.scoreProvider = null;\r\n    }\r\n\r\n}\r\n\r\n\r\nexport class FilterState {\r\n\r\n    /**\r\n     * @param {FilterStateInternal} internalState\r\n     */\r\n\r\n    constructor( internalState ) {\r\n\r\n        // Closure over the internal state to make it read-only.\r\n\r\n        this.abort = function abort(keepResults = false){\r\n            internalState.isActive = false;\r\n            internalState.shouldAbort = true;\r\n            internalState.discardResults = !keepResults;\r\n        };\r\n\r\n        this.isActive = function isActive(){\r\n            return internalState.isActive;\r\n        };\r\n\r\n        this.isCanceled = function isCanceled(){\r\n            return internalState.shouldAbort;\r\n        };\r\n\r\n        this.getProgressCount = function getProgressCount(){\r\n            return internalState.count;\r\n        };\r\n\r\n    }\r\n}\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/filterState.js","// A match list is an array of indexes to characters that match.\r\n// This file should closely follow `scorer` except that it returns an array\r\n// of indexes instead of a score.\r\nimport {isMatch, isWordStart, scoreConsecutives, scoreCharacter, scoreAcronyms} from \"./scorer\";\r\n\r\n\r\nexport default{\r\n    match,\r\n    wrap,\r\n}\r\n\r\n\r\n// Return position of character which matches\r\n\r\n/**\r\n *\r\n * @param {string} string\r\n * @param {Query} preparedQuery\r\n * @param {MatchOptions} options\r\n * @returns {Array.<number>}\r\n */\r\nexport function match(string, preparedQuery, options) {\r\n\r\n    let {allowErrors, pathSeparator} = options;\r\n\r\n    if (!allowErrors && !isMatch(string, preparedQuery.core_lw, preparedQuery.core_up)) {\r\n        return [];\r\n    }\r\n    let string_lw = string.toLowerCase();\r\n\r\n    // Full path results\r\n    let matches = computeMatch(string, string_lw, preparedQuery);\r\n\r\n    //if there is no matches on the full path, there should not be any on the base path either.\r\n    if (matches.length === 0) {\r\n        return matches;\r\n    }\r\n\r\n    // Is there a base path ?\r\n    if (string.indexOf(pathSeparator) > -1) {\r\n\r\n        // Base path results\r\n        let baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);\r\n\r\n        // Combine the results, removing duplicate indexes\r\n        matches = mergeMatches(matches, baseMatches);\r\n    }\r\n\r\n    return matches;\r\n}\r\n\r\n\r\n//\r\n// Wrap\r\n//\r\n// Helper around match if you want a string with result wrapped by some delimiter text\r\n\r\n/**\r\n *\r\n * @param {string} string\r\n * @param {Query} preparedQuery\r\n * @param {WrapOptions} options\r\n * @returns {*}\r\n */\r\nexport function wrap(string, preparedQuery, options) {\r\n\r\n    let tagClass = options.tagClass ||  'highlight';\r\n    let tagOpen = options.tagOpen || `<strong class=\"${tagClass}\">`;\r\n    let tagClose = options.tagClose || '</strong>';\r\n\r\n    if (string === preparedQuery.query) {\r\n        return tagOpen + string + tagClose;\r\n    }\r\n\r\n    //Run get position where a match is found\r\n    let matchPositions = match(string, preparedQuery, options);\r\n    let nbMatches = matchPositions.length;\r\n\r\n    //If no match return as is\r\n    if (nbMatches === 0) {\r\n        return string;\r\n    }\r\n\r\n    //Loop over match positions\r\n    let output = '';\r\n    let matchIndex = -1;\r\n    let strPos = 0;\r\n    while (++matchIndex < nbMatches) {\r\n        let matchPos = matchPositions[matchIndex];\r\n\r\n        // Get text before the current match position\r\n        if (matchPos > strPos) {\r\n            output += string.substring(strPos, matchPos);\r\n            strPos = matchPos;\r\n        }\r\n\r\n        // Get consecutive matches to wrap under a single tag\r\n        while (++matchIndex < nbMatches) {\r\n            if (matchPositions[matchIndex] === matchPos + 1) {\r\n                matchPos++;\r\n            } else {\r\n                matchIndex--;\r\n                break;\r\n            }\r\n        }\r\n\r\n        //Get text inside the match, including current character\r\n        matchPos++;\r\n        if (matchPos > strPos) {\r\n            output += tagOpen;\r\n            output += string.substring(strPos, matchPos);\r\n            output += tagClose;\r\n            strPos = matchPos;\r\n        }\r\n    }\r\n\r\n    //Get string after last match\r\n    if (strPos < string.length - 1) {\r\n        output += string.substring(strPos);\r\n    }\r\n\r\n    //return wrapped text\r\n    return output;\r\n}\r\n\r\n\r\nfunction basenameMatch(subject, subject_lw, preparedQuery, pathSeparator) {\r\n\r\n    // Skip trailing slashes\r\n    let end = subject.length - 1;\r\n    while (subject[end] === pathSeparator) {\r\n        end--;\r\n    }\r\n\r\n    // Get position of basePath of subject.\r\n    let basePos = subject.lastIndexOf(pathSeparator, end);\r\n\r\n    //If no PathSeparator, no base path exist.\r\n    if (basePos === -1) {\r\n        return [];\r\n    }\r\n\r\n    // Get the number of folder in query\r\n    let {depth} = preparedQuery;\r\n\r\n    // Get that many folder from subject\r\n    while (depth-- > 0) {\r\n        basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\r\n        if (basePos === -1) {\r\n            return [];\r\n        }\r\n    } //consumed whole subject ?\r\n\r\n    // Get basePath match\r\n    basePos++;\r\n    end++;\r\n    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);\r\n}\r\n\r\n\r\n//\r\n// Combine two matches result and remove duplicate\r\n// (Assume sequences are sorted, matches are sorted by construction.)\r\n//\r\n\r\nfunction mergeMatches(a, b) {\r\n    let m = a.length;\r\n    let n = b.length;\r\n\r\n    if (n === 0) {\r\n        return a.slice();\r\n    }\r\n    if (m === 0) {\r\n        return b.slice();\r\n    }\r\n\r\n    let i = -1;\r\n    let j = 0;\r\n    let bj = b[j];\r\n    let out = [];\r\n\r\n    while (++i < m) {\r\n        let ai = a[i];\r\n\r\n        while (bj <= ai && ++j < n) {\r\n            if (bj < ai) {\r\n                out.push(bj);\r\n            }\r\n            bj = b[j];\r\n        }\r\n\r\n        out.push(ai);\r\n    }\r\n\r\n    while (j < n) {\r\n        out.push(b[j++]);\r\n    }\r\n\r\n    return out;\r\n}\r\n\r\n//----------------------------------------------------------------------\r\n\r\n//\r\n// Align sequence (used for fuzzaldrin.match)\r\n// Return position of subject characters that match query.\r\n//\r\n// Follow closely scorer.computeScore.\r\n// Except at each step we record what triggered the best score.\r\n// Then we trace back to output matched characters.\r\n//\r\n// Differences are:\r\n// - we record the best move at each position in a matrix, and finish by a traceback.\r\n// - we reset consecutive sequence if we do not take the match.\r\n// - no hit miss limit\r\n\r\n\r\nfunction computeMatch(subject, subject_lw, preparedQuery, offset = 0) {\r\n    let {query} = preparedQuery;\r\n    let {query_lw} = preparedQuery;\r\n\r\n    let m = subject.length;\r\n    let n = query.length;\r\n\r\n    //this is like the consecutive bonus, but for camelCase / snake_case initials\r\n    let acro_score = scoreAcronyms(subject, subject_lw, query, query_lw).score;\r\n\r\n    //Init\r\n    let score_row = new Array(n);\r\n    let csc_row = new Array(n);\r\n\r\n    // Directions constants\r\n    let STOP = 0;\r\n    let UP = 1;\r\n    let LEFT = 2;\r\n    let DIAGONAL = 3;\r\n\r\n    //Traceback matrix\r\n    let trace = new Array(m * n);\r\n    let pos = -1;\r\n\r\n    //Fill with 0\r\n    let j = -1; //0..n-1\r\n    while (++j < n) {\r\n        score_row[j] = 0;\r\n        csc_row[j] = 0;\r\n    }\r\n\r\n    let move;\r\n    let score_diag;\r\n    let score;\r\n    let score_up;\r\n    let csc_diag;\r\n\r\n    let i = -1; //0..m-1\r\n    while (++i < m) { //foreach char si of subject\r\n\r\n        score = 0;\r\n        score_up = 0;\r\n        csc_diag = 0;\r\n\r\n        let si_lw = subject_lw[i];\r\n\r\n        j = -1; //0..n-1\r\n        while (++j < n) { //foreach char qj of query\r\n\r\n            //reset score\r\n            let csc_score = 0;\r\n            let align = 0;\r\n            score_diag = score_up;\r\n\r\n            //Compute a tentative match\r\n            if (query_lw[j] === si_lw) {\r\n\r\n                let start = isWordStart(i, subject, subject_lw);\r\n\r\n                // Forward search for a sequence of consecutive char\r\n                csc_score = csc_diag > 0 ? csc_diag :\r\n                    scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\r\n\r\n                // Determine bonus for matching A[i] with B[j]\r\n                align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\r\n            }\r\n\r\n            //Prepare next sequence & match score.\r\n            score_up = score_row[j]; // Current score_up is next run score diag\r\n            csc_diag = csc_row[j];\r\n\r\n            //In case of equality, moving UP get us closer to the init of the candidate string.\r\n            if (score > score_up) {\r\n                move = LEFT;\r\n            } else {\r\n                score = score_up;\r\n                move = UP;\r\n            }\r\n\r\n            // Only take alignment if it's the absolute best option.\r\n            if (align > score) {\r\n                score = align;\r\n                move = DIAGONAL;\r\n            } else {\r\n                //If we do not take this character, break consecutive sequence.\r\n                // (when consecutive is 0, it'll be recomputed)\r\n                csc_score = 0;\r\n            }\r\n\r\n            score_row[j] = score;\r\n            csc_row[j] = csc_score;\r\n            trace[++pos] = (score > 0) ? move : STOP;\r\n        }\r\n    }\r\n\r\n    // -------------------\r\n    // Go back in the trace matrix\r\n    // and collect matches (diagonals)\r\n\r\n    i = m - 1;\r\n    j = n - 1;\r\n    pos = (i * n) + j;\r\n    let backtrack = true;\r\n    let matches = [];\r\n\r\n    while (backtrack && i >= 0 && j >= 0) {\r\n        switch (trace[pos]) {\r\n            case UP:\r\n                i--;\r\n                pos -= n;\r\n                break;\r\n            case LEFT:\r\n                j--;\r\n                pos--;\r\n                break;\r\n            case DIAGONAL:\r\n                matches.push(i + offset);\r\n                j--;\r\n                i--;\r\n                pos -= n + 1;\r\n                break;\r\n            default:\r\n                backtrack = false;\r\n        }\r\n    }\r\n\r\n    matches.reverse();\r\n    return matches;\r\n}\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/matcher.js","//\r\n// Query object\r\n//\r\n// Allow to reuse some quantities computed from query.\r\n// Optional char can optionally be specified in the form of a regular expression.\r\n//\r\nimport {countDir, getExtension} from \"./pathScorer\";\r\n\r\nexport class Query {\r\n\r\n    constructor(query, options) {\r\n\r\n        if (query == null || !query.length) {\r\n            return;\r\n        }\r\n\r\n        this.query = query;\r\n        this.query_lw = query.toLowerCase();\r\n        this.core = coreChars(query, options.optCharRegEx);\r\n        this.core_lw = this.core.toLowerCase();\r\n        this.core_up = truncatedUpperCase(this.core);\r\n        this.depth = countDir(query, query.length, options.pathSeparator);\r\n        this.ext = getExtension(this.query_lw);\r\n        this.charCodes = getCharCodes(this.query_lw);\r\n    }\r\n}\r\n\r\n\r\n//\r\n// Optional chars\r\n// Those char improve the score if present, but will not block the match (score=0) if absent.\r\n\r\nconst opt_char_re = /[ _\\-:\\/\\\\]/g;\r\n\r\nfunction coreChars(query, optCharRegEx) {\r\n\r\n    if (optCharRegEx == null) {\r\n        optCharRegEx = opt_char_re\r\n    }\r\n\r\n    return query.replace(optCharRegEx, '');\r\n}\r\n\r\n//\r\n// Truncated Upper Case:\r\n// --------------------\r\n//\r\n// A fundamental mechanic is that we are able to keep uppercase and lowercase variant of the strings in sync.\r\n// For that we assume uppercase and lowercase version of the string have the same length.\r\n// Of course unicode being unicode there's exceptions.\r\n// See ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt for the list\r\n//\r\n// \"Straße\".toUpperCase() -> \"STRASSE\"\r\n// truncatedUpperCase(\"Straße\") -> \"STRASE\"\r\n// iterating over every character, getting uppercase variant and getting first char of that.\r\n//\r\n\r\nfunction truncatedUpperCase(str) {\r\n    let upper = \"\";\r\n    for (let char of str) {\r\n        upper += char.toUpperCase()[0];\r\n    }\r\n    return upper;\r\n}\r\n\r\n//\r\n// Get character codes:\r\n// --------------------\r\n//\r\n// Get character codes map for a given string\r\n//\r\n\r\nfunction getCharCodes(str) {\r\n    let len = str.length;\r\n    let i = -1;\r\n\r\n    let charCodes = [];\r\n    // create map\r\n    while (++i < len) {\r\n        charCodes[str.charCodeAt(i)] = true;\r\n    }\r\n\r\n    return charCodes;\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/query.js","export default {\r\n    isFunction,\r\n    isArray,\r\n    getIterator,\r\n    isIteratorItem\r\n};\r\n\r\nexport function isFunction(fn){\r\n    return typeof fn === \"function\"\r\n}\r\n\r\nexport function isArray(tentativeArray){\r\n\r\n    if( isFunction(Array.isArray) ){\r\n        return Array.isArray(tentativeArray);\r\n    }\r\n\r\n    return Object.prototype.toString.call(tentativeArray) === \"[object Array]\";\r\n\r\n}\r\n\r\n//\r\n// Es6 compatible iterator.\r\n// Follow convention of ImmutableJS\r\n//\r\n\r\nconst REAL_ITERATOR_SYMBOL = (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") ? Symbol.iterator : null;\r\nconst FAUX_ITERATOR_SYMBOL = '@@iterator';\r\n\r\nexport function getIterator(object){\r\n\r\n    if(object == null) return null;\r\n\r\n    // Get iterator from Iterable\r\n    let iterator = null;\r\n    if(REAL_ITERATOR_SYMBOL != null && isFunction(object[REAL_ITERATOR_SYMBOL]) ) {\r\n        // real es6 Iterable\r\n        iterator =  object[REAL_ITERATOR_SYMBOL]();\r\n    }\r\n    else if( isFunction(object[REAL_ITERATOR_SYMBOL]) ){\r\n        // es < 6 fallback.\r\n        iterator = object[FAUX_ITERATOR_SYMBOL]();\r\n    }\r\n\r\n    // Ensure that that iterator implements 'next' function\r\n    if(iterator != null && isFunction(iterator.next))\r\n        return iterator;\r\n\r\n    // Test if object itself is iterator-like\r\n    if(isFunction(object.next)){\r\n        return object;\r\n    }\r\n\r\n    return null;\r\n\r\n}\r\n\r\nexport function isIteratorItem(item){\r\n    return  item != null && 'done' in item && 'value' in item\r\n}\n\n\n// WEBPACK FOOTER //\n// ./C:/Users/JeanChristophe/Documents/GitHub/fuzzaldrin-plus/src/lib/utils.js"],"sourceRoot":""}