{"version":3,"file":"fuzzaldrin-plus.js","sources":["webpack:///webpack/bootstrap 525233908aa0b11363cf","webpack:///./src/fuzzaldrin-plus.js","webpack:///./src/lib/filter.js","webpack:///./src/lib/scorer.js","webpack:///./src/lib/pathScorer.js","webpack:///./src/lib/utils.js","webpack:///./src/lib/matcher.js","webpack:///./src/lib/query.js"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 525233908aa0b11363cf","\"use strict\";\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.filter = filter;\nexports.filterAsync = filterAsync;\nexports.score = score;\nexports.match = match;\nexports.wrap = wrap;\nexports.prepareQuery = prepareQuery;\n\nvar _filter = require(\"./lib/filter\");\n\nvar _scorer = require(\"./lib/scorer\");\n\nvar _pathScorer = require(\"./lib/pathScorer\");\n\nvar _matcher = require(\"./lib/matcher\");\n\nvar _query = require(\"./lib/query\");\n\nvar fuzzaldrin = {\n    filter: filter,\n    score: score,\n    match: match,\n    wrap: wrap,\n    prepareQuery: prepareQuery\n};\n\nexports.default = fuzzaldrin;\n\n\nvar preparedQueryCache = null;\n\n/**\r\n * Filter:\r\n *  Given a list of candidate, output a list of candidate that match query.\r\n *  Output list is the same format (string or object) than input list.\r\n *\r\n *  If given a list of object, specify options.key as the property `candidate[key]`\r\n *  that contain the string representation of the candidate\r\n *\r\n *  Output is sorted by match score.\r\n *\r\n * @param {Array.<(string|object)>|Iterable} candidates - array of string or objects\r\n * @param {string} query - string to search for in each candidate\r\n * @param {FilterOptions=} options - (optional) see option hash doc\r\n * @returns {Array.<(string|object)>} - filtered & sorted subset of input candidates\r\n */\n\nfunction filter(candidates, query, options) {\n\n    if (!checkString(query)) return [];\n    if (!checkCollection(candidates)) return [];\n\n    options = parseOptions(options, query);\n    return (0, _filter.filterSync)(candidates, query, options);\n}\n\n/**\r\n *\r\n * @param candidates\r\n * @param query\r\n * @param options\r\n * @param {filterCallback} callback\r\n * @returns {FilterState}\r\n */\n\nfunction filterAsync(candidates, query, callback, options) {\n\n    if (!checkString(query)) return [];\n    if (!checkCollection(candidates)) return [];\n\n    options = parseOptions(options, query);\n    return (0, _filter.filterAsync)(candidates, query, callback, options);\n}\n\n/**\r\n * Score:\r\n *   Give the numerical score on how a given string match query.\r\n *\r\n *   This is provided so you can build your own filter method.\r\n *   For example you may have a special way to iterate candidate,\r\n *   access candidate string representation, or you may need to\r\n *   modify the score to account external knowledge (eg last modified date)\r\n *\r\n * @param {string} string - string representation of a candidate\r\n * @param {string} query - string to search for in candidate\r\n * @param {ScoringOptions=} options - (optional) see option hash doc\r\n * @returns {number} score 0 .. max, where max is score(string, string)\r\n */\n\nfunction score(string, query, options) {\n\n    if (!checkString(string)) return 0;\n    if (!checkString(query)) return 0;\n\n    options = parseOptions(options, query);\n\n    if (options.usePathScoring) {\n        return (0, _pathScorer.score)(string, query, options);\n    } else {\n        return (0, _scorer.score)(string, query, options);\n    }\n}\n\n/**\r\n * Match:\r\n *    Communicate which characters of candidate where selected by the algorithm to represent the query.\r\n *    The match function output an array of character position.\r\n *    If you need to display those character as an html string see wrap function.\r\n *\r\n * @param {string} string - string representation of a candidate\r\n * @param {string} query - string to search for in candidate\r\n * @param {MatchOptions=} options (optional)\r\n * @returns {Array.<number>}\r\n */\n\nfunction match(string, query, options) {\n\n    if (!checkString(string)) return [];\n    if (!checkString(query)) return [];\n\n    //If both are the same, return an array of consecutive numbers\n    if (string === query) {\n        var length = string.length;\n        var range = new Array(length);\n        for (var idx = 0; idx < length; idx++) {\n            range[idx] = idx;\n        }\n        return range;\n    }\n\n    options = parseOptions(options, query);\n    return (0, _matcher.match)(string, query, options);\n}\n\n/**\r\n * Wrap:\r\n *    Communicate which characters of candidate where selected by the algorithm to represent the query.\r\n *    This function output the given string with chosen character wrapped in a delimiter string (eg html tag).\r\n *\r\n *    To control the wrap use the option hash.\r\n *    Here are some default value:\r\n *      options.tagOpen = `<strong class=\"highlight\">`\r\n *      options.tagClose = `</strong>`\r\n *\r\n *    Alternatively, if you chose to keep the default tagOpen,\r\n *    you can specify option.tagClass and change the `highlight`\r\n *    class to one of your choosing.\r\n *\r\n *    Wrap method will try to group consecutive matches under the same tag.\r\n *\r\n * @param {string} string - string representation of a candidate\r\n * @param {string} query - string to search for in candidate\r\n * @param {WrapOptions=} options\r\n * @returns {string} - input string with match wrapped in open and close tag.\r\n */\n\nfunction wrap(string, query, options) {\n\n    if (!checkString(string)) return \"\";\n    if (!checkString(query)) return string;\n\n    options = parseOptions(options, query);\n    return (0, _matcher.wrap)(string, query, options);\n}\n\n/**\r\n * PrepareQuery:\r\n *   The usual scenario is to compare a single query with multiple candidate.\r\n *   To speed that process up, we pre-compute some information about the query.\r\n *\r\n *   Pre-computed query is natural to use in bulk method like filter, but harder\r\n *   in one-by-one method like score or match. To keep those method fast you can give\r\n *   a pre computed query in option hash as `options.preparedQuery`\r\n *\r\n *   Note that we use an internal cache `preparedQueryCache` that cover most of the simple cases\r\n *   So this method may not be needed in thos cases.\r\n *\r\n * @param {string} query\r\n * @param {QueryOptions} options\r\n * @returns {Query}\r\n */\n\nfunction prepareQuery(query, options) {\n    options = parseOptions(options, query);\n    return options.preparedQuery;\n}\n\nfunction checkString(str) {\n    //Not null, must have length property > 0\n    return str != null && str.length != null && str.length > 0;\n}\n\nfunction checkCollection(obj) {\n    // Not null\n    // If object has length or size property, must be != 0\n    return obj != null && obj.length !== 0 && obj.size !== 0;\n}\n\n//\n// Detect node.js or browser to set default path separator\n//\n\nvar defaultPathSeparator = \"/\";\n\nif ((typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === 'object' && Object.prototype.toString.call(process) === '[object process]') {\n\n    // On node js we assume the list of candidates match local OS path format.\n    // See comment bellow to change behavior.\n    defaultPathSeparator = process.platform === \"win32\" ? '\\\\' : '/';\n} else if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object' && Object.prototype.toString.call(window) === \"[object Window]\") {\n\n    // We assume that browser are dealing with url, if assumption is false use option hash like so:\n    // fuzzaldrin.filter( candidates, query, {pathSeparator: platformSep} )\n    // and determine `platformSep` any so it match the format of candidates.\n\n    defaultPathSeparator = \"/\";\n\n    // Export main object to global window.\n    window.fuzzaldrin = fuzzaldrin;\n}\n\n//\n// Setup default values\n//\n\n/**\r\n * @type {ScoringOptions}\r\n */\nvar defaultOptions = {\n    allowErrors: false,\n    usePathScoring: true,\n    useExtensionBonus: false,\n    pathSeparator: defaultPathSeparator,\n    optCharRegEx: null,\n    preparedQuery: null\n};\n\n/**\r\n *\r\n * @param {(ScoringOptions|FilterOptions|MatchOptions|WrapOptions)} options\r\n * @param {string} query\r\n * @returns {(ScoringOptions|FilterOptions|MatchOptions|WrapOptions)} options completed with default values from ScoringOptions\r\n */\n\nfunction parseOptions(options, query) {\n\n    // If no options given, copy default\n    // Else merge options with defaults.\n\n    if (options == null) options = {};\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n    for (var key in defaultOptions) {\n        if (hasOwnProperty.call(defaultOptions, key) && !hasOwnProperty.call(options, key)) {\n            options[key] = defaultOptions[key];\n        }\n    }\n\n    // if preparedQuery is given use it\n    // else assign from cache, recompute cache if needed\n    if (options.preparedQuery == null) {\n\n        if (preparedQueryCache == null || preparedQueryCache.query !== query) {\n            preparedQueryCache = new _query.Query(query, options);\n        }\n        options.preparedQuery = preparedQueryCache;\n    }\n\n    return options;\n}\n\n//\n// Documentation for option hash\n//\n\n/**\r\n * @typedef {Object} QueryOptions\r\n * @property {string} pathSeparator - If candidate are path, indicate path separator used (usually '/' or '\\\\').\r\n * @property {RegExp} optCharRegEx - Regex that identify character that does not have to match exactly, for example <whitespace>.\r\n *\r\n */\n\n/**\r\n * @typedef {Object} ScoringOptions\r\n * @extends QueryOptions\r\n *\r\n * @property {boolean} allowErrors - Should we allow candidates that does not have all characters of query ?\r\n * @property {boolean} usePathScoring - Should we try to interpret candidates as path\r\n * @property {boolean} useExtensionBonus - Should we try to interpret extension from query\r\n *                                         and prefer files that match that extension (needs usePathScoring)\r\n * @property {Query} preparedQuery - If you have a precomputed query object set it here.\r\n */\n\n/**\r\n * @typedef {Object} FilterOptions\r\n * @extends ScoringOptions\r\n *\r\n * @property {string|function} key - Name of the property that contain string ot be scored\r\n *                                   or function that input candidate and output string to be scored.\r\n *\r\n * @property {number} maxResults - Output the top `maxResults` best results at most.\r\n * @property {bool} outputScore - If true output is an array of {candidate,score} else output is an array of candidates\r\n *\r\n */\n\n/**\r\n * @typedef {Object} MatchOptions\r\n * @extends ScoringOptions\r\n *\r\n *\r\n */\n\n/**\r\n * @typedef {Object} WrapOptions\r\n * @extends MatchOptions\r\n *\r\n * @property {string} tagOpen - string to place before a match default to `<strong class=\"highlight\">`\r\n * @property {string} tagClose - string to place after a match default to `</strong>`\r\n * @property {string} tagClass - change the class of the default open tag (tagOpen must be unset)\r\n *\r\n */\n\n//\n// Async\n//\n\n/**\r\n * @callback filterCallback\r\n * @param {Array} results\r\n * @param {FilterState} state\r\n */\n\n/**\r\n * @typedef {Object} FilterState\r\n *\r\n * @method  abort - stop scoring and return no results.\r\n * @method  isActive - is the filter running.\r\n * @method  isCanceled - has the filter been canceled.\r\n * @method  getProgressCount - get the count of processed elements.\r\n *\r\n */\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/fuzzaldrin-plus.js\n// module id = 1\n// module chunks = 0","\"use strict\";\n\nexports.__esModule = true;\nexports.FilterState = undefined;\nexports.filterSync = filterSync;\nexports.filterAsync = filterAsync;\n\nvar _scorer = require(\"./scorer\");\n\nvar _scorer2 = _interopRequireDefault(_scorer);\n\nvar _pathScorer = require(\"./pathScorer\");\n\nvar _pathScorer2 = _interopRequireDefault(_pathScorer);\n\nvar _utils = require(\"./utils\");\n\nvar _utils2 = _interopRequireDefault(_utils);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nexports.default = {\n    filterSync: filterSync,\n    filterAsync: filterAsync\n};\n\n/**\r\n *\r\n * @param {Array|Iterable} candidates\r\n * @param {string} query\r\n * @param {FilterOptions} options\r\n * @returns {Array}\r\n */\n\nfunction filterSync(candidates, query, options) {\n    var state = new FilterStateInternal();\n    return executeFilter(candidates, query, state, options);\n}\n\n/**\r\n *\r\n * @param {Array|Iterable} candidates\r\n * @param {string} query\r\n * @param {FilterOptions} options\r\n * @param {filterCallback} callback\r\n * @returns {FilterState}\r\n */\n\nfunction filterAsync(candidates, query, callback, options) {\n\n    var internalState = new FilterStateInternal();\n    var publicState = new FilterState(internalState);\n\n    var scheduled = function scheduled() {\n        callback(executeFilter(candidates, query, internalState, options), publicState);\n    };\n\n    if (typeof setImmediate === \"function\") {\n        setImmediate(scheduled);\n    } else {\n        setTimeout(scheduled, 0);\n    }\n\n    return publicState;\n}\n\n/**\r\n *\r\n * @param {Array|Iterable} candidates\r\n * @param {string} query\r\n * @param {FilterStateInternal} state\r\n * @param {FilterOptions} options\r\n * @returns {Array}\r\n */\n\nfunction executeFilter(candidates, query, state, options) {\n\n    if (state.shouldAbort) return [];\n\n    // See option parsing on main module for default\n    var key = options.key,\n        maxResults = options.maxResults,\n        outputScore = options.outputScore,\n        usePathScoring = options.usePathScoring;\n\n    var scoreProvider = usePathScoring ? _pathScorer2.default : _scorer2.default;\n\n    // If list of object, we need to get the string to be scored, as defined by options.key\n    // If the key is a method, that method should take an object and return the string.\n    // Else we assume it is the name of a property on candidate object.\n    var accessor = null;\n    if (key != null) {\n        accessor = _utils2.default.isFunction(options.key) ? options.key : function (x) {\n            return x[key];\n        };\n    }\n\n    // Init state\n    state.isActive = true;\n    state.accessor = accessor;\n    state.scoreProvider = scoreProvider;\n    state.scoredCandidates = [];\n\n    // Iterate candidate list and collect scored positive matches.\n    processCollection(candidates, query, state, options);\n\n    // Collect positives matches\n    var scoredCandidates = state.scoredCandidates;\n\n    // Cleanup\n    state.scoredCandidates = null;\n    state.isActive = false;\n\n    // Quick exit\n    if (state.shouldAbort || scoredCandidates == null || !scoredCandidates.length) return [];\n\n    // Sort scores in descending order\n    scoredCandidates.sort(sortCandidates);\n\n    // Trim to maxResults if specified\n    if (maxResults != null) {\n        scoredCandidates = scoredCandidates.slice(0, maxResults);\n    }\n\n    if (outputScore === true) {\n        return scoredCandidates;\n    } else {\n        // Extract original candidate and return\n        return scoredCandidates.map(pluckCandidates);\n    }\n}\n\nfunction processCollection(collection, query, state, options) {\n\n    //\n    // Collection is an array\n    //\n\n    if (_utils2.default.isArray(collection)) {\n        for (var i = 0; i <= collection.length; i++) {\n            if (!processItem(collection[i], query, state, options)) break;\n        }\n\n        return;\n    }\n\n    //\n    // Collection implements es6 iterator protocol\n    //\n\n    var iterator = _utils2.default.getIterator(collection);\n    if (iterator != null) {\n        var item = void 0;\n        while (item = iterator.next()) {\n            if (item.done) break;\n            if (!processItem(item.value, query, state, options)) break;\n        }\n\n        return;\n    }\n\n    //\n    // Collection implements 'forEach'\n    //\n\n    // Some implementations  of foreach allow to exit using return false. (Eg Immutablejs)\n    //      processItem follow that convention .\n    //\n    // Others cannot be interrupted ( Eg default Array.forEach )\n    //      so we continue iteration but short circuit most of the work.\n\n    var cont = true;\n    if (_utils2.default.isFunction(collection.forEach)) {\n        collection.forEach(function (item) {\n            return cont = cont && processItem(item, query, state, options);\n        });\n    }\n}\n\n/**\r\n *\r\n * @param {string|object} candidate\r\n * @param {string} query\r\n * @param {FilterStateInternal} context\r\n * @param {FilterOptions} options\r\n * @returns {boolean}\r\n */\n\nfunction processItem(candidate, query, context, options) {\n\n    if (context.shouldAbort) return false;\n    context.count++;\n\n    var accessor = context.accessor,\n        scoredCandidates = context.scoredCandidates,\n        scoreProvider = context.scoreProvider;\n\n    // Get the string representation of candidate\n\n    var string = accessor != null ? accessor(candidate) : candidate;\n    if (string == null || !string.length) {\n        return true;\n    }\n\n    // Get score, If score greater than 0 add to valid results\n    var score = scoreProvider.score(string, query, options);\n    if (score > 0) {\n        scoredCandidates.push({ candidate: candidate, score: score });\n    }\n\n    return true;\n}\n\nfunction pluckCandidates(a) {\n    return a.candidate;\n}\n\nfunction sortCandidates(a, b) {\n    return b.score - a.score;\n}\n\nvar FilterStateInternal = function FilterStateInternal() {\n    _classCallCheck(this, FilterStateInternal);\n\n    this.isActive = false;\n    this.shouldAbort = false;\n    this.count = 0;\n    this.scoredCandidates = null;\n    this.accessor = null;\n    this.scoreProvider = null;\n};\n\nvar FilterState =\n\n/**\r\n * @param {FilterStateInternal} internalState\r\n */\n\nexports.FilterState = function FilterState(internalState) {\n    _classCallCheck(this, FilterState);\n\n    // Closure over the internal state to make it read-only.\n\n    this.abort = function () {\n        internalState.isActive = false;\n        internalState.shouldAbort = true;\n    };\n\n    this.isActive = function () {\n        return internalState.isActive;\n    };\n\n    this.isCanceled = function () {\n        return internalState.shouldAbort;\n    };\n\n    this.getProgressCount = function () {\n        return internalState.count;\n    };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lib/filter.js\n// module id = 2\n// module chunks = 0","'use strict';\n\nexports.__esModule = true;\nexports.score = score;\nexports.isMatch = isMatch;\nexports.computeScore = computeScore;\nexports.isWordStart = isWordStart;\nexports.isWordEnd = isWordEnd;\nexports.isSeparator = isSeparator;\nexports.scorePosition = scorePosition;\nexports.scoreSize = scoreSize;\nexports.scoreExact = scoreExact;\nexports.scorePattern = scorePattern;\nexports.scoreCharacter = scoreCharacter;\nexports.scoreConsecutives = scoreConsecutives;\nexports.scoreExactMatch = scoreExactMatch;\nexports.scoreAcronyms = scoreAcronyms;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//\n// Score similarity between two string\n//\n//  isMatch: Fast detection if all character of needle is in haystack\n//  score: Find string similarity using a Smith Waterman algorithm\n//         Modified to account for programing scenarios (CamelCase folder/file.ext object.property)\n//\n// Copyright (C) 2015 Jean Christophe Roy and contributors\n// MIT License: http://opensource.org/licenses/MIT\n\n\n// Base point for a single character match\n// This balance making patterns VS position and size penalty.\nvar wm = 150;\n\n//Fading function\nvar pos_bonus = 20; // The character from 0..pos_bonus receive a greater bonus for being at the init of string.\nvar tau_size = 85; // Full path length at which the whole match score is halved.\n\n// Miss count\n// When subject[i] is query[j] we register a hit.\n// Limiting hit put a boundary on how many permutation we consider to find the best one.\n// Helps to speed-up processing of long path and query containing frequent character (eg vowels)\n//\n// If a spec with frequent repetition fail, increase this.\n// This has a direct influence on worst case scenario benchmark.\nvar miss_coeff = 0.75; //Max number missed consecutive hit = ceil(miss_coeff*query.length) + 5\n\n\n//\n// Main export\n//\n\nexports.default = {\n\n    score: score,\n    isMatch: isMatch\n\n};\n\n\n// Manage the logic of testing if there's a match and calling the main scoring function\n// Also manage scoring a path and optional character.\n\nfunction score(string, query, options) {\n    var preparedQuery = options.preparedQuery,\n        allowErrors = options.allowErrors;\n\n    if (!allowErrors && !isMatch(string, preparedQuery.core_lw, preparedQuery.core_up)) {\n        return 0;\n    }\n    var string_lw = string.toLowerCase();\n    var score = computeScore(string, string_lw, options);\n    return Math.ceil(score);\n}\n\n//\n// isMatch:\n// Are all (non optional)characters of query in subject, in proper order ?\n//\n\nfunction isMatch(subject, query_lw, query_up) {\n    var m = subject.length;\n    var n = query_lw.length;\n\n    if (!m || n > m) {\n        return false;\n    }\n\n    var i = -1;\n    var j = -1;\n\n    //foreach char of query\n    while (++j < n) {\n\n        var qj_lw = query_lw.charCodeAt(j);\n        var qj_up = query_up.charCodeAt(j);\n\n        // Continue walking the subject from where we have left with previous query char\n        // until we have found a character that is either lowercase or uppercase query.\n        while (++i < m) {\n            var si = subject.charCodeAt(i);\n            if (si === qj_lw || si === qj_up) {\n                break;\n            }\n        }\n\n        // If we passed the last char, query is not in subject\n        if (i === m) {\n            return false;\n        }\n    }\n\n    // Found every char of query in subject in proper order, match is positive\n    return true;\n}\n\n//----------------------------------------------------------------------\n//\n// Main scoring algorithm\n//\n\nfunction computeScore(subject, subject_lw, options) {\n    var preparedQuery = options.preparedQuery;\n    var query = preparedQuery.query,\n        query_lw = preparedQuery.query_lw;\n\n    var flexUppercase = true;\n\n    var m = subject.length;\n    var n = query.length;\n    var current_score = 0;\n\n    //----------------------------\n    // Abbreviations sequence\n\n    var acro = scoreAcronyms(subject, subject_lw, query, query_lw);\n    var acro_score = acro.score;\n\n    // Whole query is abbreviation ?\n    // => use that as score\n    if (acro.count === n) {\n        return scoreExact(n, m, acro_score, acro.pos);\n    }\n\n    //----------------------------\n    // Exact Match ?\n    // => use that as score\n\n    var pos = subject_lw.indexOf(query_lw);\n    if (pos > -1) {\n        return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);\n    }\n\n    //----------------------------\n    // Individual characters\n    // (Smith Waterman algorithm)\n\n\n    //Init\n    var score_row = new Array(n);\n    var csc_row = new Array(n);\n    var sz = scoreSize(n, m);\n\n    var miss_budget = Math.ceil(miss_coeff * n) + 5;\n    var miss_left = miss_budget;\n\n    //Fill with 0\n    var j = -1;\n    while (++j < n) {\n        score_row[j] = 0;\n        csc_row[j] = 0;\n    }\n\n    // Limit the search to the isActive region\n    // for example with query `abc`, subject `____a_bc_ac_c____`\n    // there's a region before first `a` and after last `c`\n    // that can be simplified out of the matching process\n\n    // Before first occurrence in subject of first letter of query, or -1\n    var i = subject_lw.indexOf(query_lw[0]);\n    if (i > -1) {\n        i--;\n    }\n\n    // After last occurrence of last letter of query,\n    var mm = subject_lw.lastIndexOf(query_lw[n - 1], m);\n    if (mm > i) {\n        m = mm + 1;\n    }\n\n    var csc_invalid = true;\n\n    while (++i < m) {\n        //foreach char si of subject\n\n        var si_lw = subject_lw[i];\n\n        // if si_lw is not in query\n        if (preparedQuery.charCodes[si_lw.charCodeAt(0)] == null) {\n            // reset csc_row and move to next\n            if (csc_invalid !== true) {\n                j = -1;\n                while (++j < n) {\n                    csc_row[j] = 0;\n                }\n                csc_invalid = true;\n            }\n            continue;\n        }\n\n        var si = subject_lw[i];\n\n        current_score = 0;\n        var score_diag = 0;\n        var csc_diag = 0;\n        var record_miss = true;\n        csc_invalid = false;\n\n        j = -1; //0..n-1\n        while (++j < n) {\n            //foreach char qj of query\n\n            // What is the best gap ?\n            // score_up contain the score of a gap in subject.\n            // score_left = last iteration of score, -> gap in query.\n            var score_up = score_row[j];\n            if (score_up > current_score) {\n                current_score = score_up;\n            }\n\n            //Reset consecutive\n            var csc_score = 0;\n            var qj_lw = query_lw[j];\n\n            // Compute a tentative match\n            // First check case-insesitive match\n            if (qj_lw === si_lw) {\n\n                // Refine for strict Uppercase\n                //\n                // When do we have a match ?\n                // A) Case Insensitive Match && Not strict Uppercase\n                // B) Case Insensitive Match && Query is lowercase\n                // C) Case Sensitive Match. (Imply Case Insensitive)\n\n                var qj = query[j];\n                if (flexUppercase || qj_lw === qj || si === qj) {\n\n                    var start = isWordStart(i, subject, subject_lw);\n\n                    // Forward search for a sequence of consecutive char\n                    csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n\n                    // Determine bonus for matching A[i] with B[j]\n                    var align_score = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n\n                    //Are we better using this match or taking the best gap (currently stored in score)?\n                    if (align_score > current_score) {\n                        current_score = align_score;\n                        // reset consecutive missed hit count\n                        miss_left = miss_budget;\n                    } else {\n                        // We rejected this match and record a miss.\n                        // If budget is exhausted exit\n                        if (record_miss && --miss_left <= 0) {\n                            return score_row[n - 1] * sz;\n                        }\n                        record_miss = false;\n                    }\n                }\n            }\n\n            //Prepare next sequence & match score.\n            score_diag = score_up;\n            csc_diag = csc_row[j];\n            csc_row[j] = csc_score;\n            score_row[j] = current_score;\n        }\n    }\n\n    // get highest score so far\n    current_score = score_row[n - 1];\n    return current_score * sz;\n}\n\n//\n// Boundaries\n//\n// Is the character at the init of a word, end of the word, or a separator ?\n// Fortunately those small function inline well.\n//\n\nfunction isWordStart(pos, subject, subject_lw) {\n    if (pos === 0) {\n        return true;\n    } // match is FIRST char ( place a virtual token separator before first char of string)\n    var curr_s = subject[pos];\n    var prev_s = subject[pos - 1];\n    return isSeparator(prev_s) || // match FOLLOW a separator\n    curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1]; // match is Capital in camelCase (preceded by lowercase)\n}\n\nfunction isWordEnd(pos, subject, subject_lw, len) {\n    if (pos === len - 1) {\n        return true;\n    } // last char of string\n    var curr_s = subject[pos];\n    var next_s = subject[pos + 1];\n    return isSeparator(next_s) || // match IS FOLLOWED BY a separator\n    curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1]; // match is lowercase, followed by uppercase\n}\n\nfunction isSeparator(c) {\n    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\\\';\n}\n//\n// Scoring helper\n//\n\nfunction scorePosition(pos) {\n    if (pos < pos_bonus) {\n        var sc = pos_bonus - pos;\n        return 100 + sc * sc;\n    } else {\n        return Math.max(100 + pos_bonus - pos, 0);\n    }\n}\n\nfunction scoreSize(n, m) {\n    // Size penalty, use the difference of size (m-n)\n    return tau_size / (tau_size + Math.abs(m - n));\n}\n\nfunction scoreExact(n, m, quality, pos) {\n    return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);\n}\n\n//\n// Shared scoring logic between exact match, consecutive & acronym\n// Ensure pattern length dominate the score then refine to take into account case-sensitivity\n// and structural quality of the pattern on the overall string (word boundary)\n//\n\nfunction scorePattern(count, len, sameCase, start, end) {\n    var sz = count;\n\n    var bonus = 6; // to ensure consecutive length dominate score, this should be as large other bonus combined\n    if (sameCase === count) {\n        bonus += 2;\n    }\n    if (start) {\n        bonus += 3;\n    }\n    if (end) {\n        bonus += 1;\n    }\n\n    if (count === len) {\n        // when we match 100% of query we allow to break the size ordering.\n        // This is to help exact match bubble up vs size, depth penalty etc\n        if (start) {\n            if (sameCase === len) {\n                sz += 2;\n            } else {\n                sz += 1;\n            }\n        }\n        if (end) {\n            bonus += 1;\n        }\n    }\n\n    return sameCase + sz * (sz + bonus);\n}\n\n//\n// Compute the bonuses for two chars that are confirmed to matches in a case-insensitive way\n//\n\nfunction scoreCharacter(i, j, start, acro_score, csc_score) {\n\n    // init of string / position of match bonus\n    var posBonus = scorePosition(i);\n\n    // match IS a word boundary\n    // choose between taking part of consecutive characters or consecutive acronym\n    if (start) {\n        return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);\n    }\n\n    // normal Match\n    return posBonus + wm * csc_score;\n}\n\n//\n// Forward search for a sequence of consecutive character.\n//\n\nfunction scoreConsecutives(subject, subject_lw, query, query_lw, i, j, startOfWord) {\n    var m = subject.length;\n    var n = query.length;\n\n    var mi = m - i;\n    var nj = n - j;\n    var k = mi < nj ? mi : nj;\n\n    var sameCase = 0;\n\n    // query_lw[i] is subject_lw[j] has been checked before entering now do case sensitive check.\n    if (query[j] === subject[i]) {\n        sameCase++;\n    }\n\n    // size of consecutive\n    // sz will be one more than the last index where query[j] == subject[i] (lowercase)\n    var sz = 0;\n\n    //Continue while lowercase char are the same, record when they are case-sensitive match.\n    while (++sz < k && query_lw[++j] === subject_lw[++i]) {\n        if (query[j] === subject[i]) {\n            sameCase++;\n        }\n    }\n\n    // Faster path for single match.\n    // Isolated character match occurs often and are not really interesting.\n    // Fast path so we don't compute expensive pattern score on them.\n    // Acronym should be addressed with acronym context bonus instead of consecutive.\n    if (sz === 1) {\n        return 1 + 2 * sameCase;\n    }\n\n    return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));\n}\n\n//\n// Compute the score of an exact match at position pos.\n//\n\nfunction scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m) {\n\n    // Test for word init\n    var start = isWordStart(pos, subject, subject_lw);\n\n    // Heuristic\n    // If not a word init, test next occurrence\n    // - We want exact match to be fast\n    // - For exact match, word init has the biggest impact on score.\n    // - Testing 2 instances is somewhere between testing only one and testing every instances.\n\n    if (!start) {\n        var pos2 = subject_lw.indexOf(query_lw, pos + 1);\n        if (pos2 > -1) {\n            start = isWordStart(pos2, subject, subject_lw);\n            if (start) {\n                pos = pos2;\n            }\n        }\n    }\n\n    //Exact case bonus.\n    var i = -1;\n    var sameCase = 0;\n    while (++i < n) {\n        if (query[pos + i] === subject[i]) {\n            sameCase++;\n        }\n    }\n\n    var end = isWordEnd(pos + n - 1, subject, subject_lw, m);\n\n    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);\n}\n\n//\n// Acronym prefix\n//\n\n\nvar AcronymResult = function AcronymResult(score, pos, count) {\n    _classCallCheck(this, AcronymResult);\n\n    this.score = score;\n    this.pos = pos;\n    this.count = count;\n};\n\nvar emptyAcronymResult = new AcronymResult(0, 0.1, 0);\n\nfunction scoreAcronyms(subject, subject_lw, query, query_lw) {\n    var m = subject.length;\n    var n = query.length;\n\n    //a single char is not an acronym\n    if (m <= 1 || n <= 1) {\n        return emptyAcronymResult;\n    }\n\n    var count = 0;\n    var sepCount = 0;\n    var sumPos = 0;\n    var sameCase = 0;\n\n    var i = -1;\n    var j = -1;\n\n    //foreach char of query\n    while (++j < n) {\n\n        var qj_lw = query_lw[j];\n\n        // Separator will not score point but will continue the prefix when present.\n        // Test that the separator is in the candidate and advance cursor to that position.\n        // If no separator break the prefix\n\n        if (isSeparator(qj_lw)) {\n            i = subject_lw.indexOf(qj_lw, i + 1);\n            if (i > -1) {\n                sepCount++;\n                continue;\n            } else {\n                break;\n            }\n        }\n\n        // For other characters we search for the first match where subject[i] = query[j]\n        // that also happens to be a init-of-word\n\n        while (++i < m) {\n            if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {\n                if (query[j] === subject[i]) {\n                    sameCase++;\n                }\n                sumPos += i;\n                count++;\n                break;\n            }\n        }\n\n        // All of subject is consumed, stop processing the query.\n        if (i === m) {\n            break;\n        }\n    }\n\n    // Here, all of query is consumed (or we have reached a character not in acronym)\n    // A single character is not an acronym (also prevent division by 0)\n    if (count < 2) {\n        return emptyAcronymResult;\n    }\n\n    // Acronym are scored as init-of-word\n    // Unless the acronym is a 1:1 match with candidate then it is upgraded to full-word.\n    var fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;\n    var score = scorePattern(count, n, sameCase, true, fullWord);\n\n    return new AcronymResult(score, sumPos / count, count + sepCount);\n}\n\n//\n// Test whether there's a 1:1 relationship between query and acronym of candidate.\n// For that to happens\n// (a) All character of query must be matched to an acronym of candidate\n// (b) All acronym of candidate must be matched to a character of query.\n//\n// This method check for (b) assuming (a) has been checked before entering.\n\nfunction isAcronymFullWord(subject, subject_lw, query, nbAcronymInQuery) {\n    var m = subject.length;\n    var n = query.length;\n    var count = 0;\n\n    // Heuristic:\n    // Assume one acronym every (at most) 12 character on average\n    // This filter out long paths, but then they can match on the filename.\n    if (m > 12 * n) {\n        return false;\n    }\n\n    var i = -1;\n    while (++i < m) {\n        //For each char of subject\n        //Test if we have an acronym, if so increase acronym count.\n        //If the acronym count is more than nbAcronymInQuery (number of non separator char in query)\n        //Then we do not have 1:1 relationship.\n        if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lib/scorer.js\n// module id = 3\n// module chunks = 0","\"use strict\";\n\nexports.__esModule = true;\nexports.score = score;\nexports.countDir = countDir;\nexports.getExtension = getExtension;\nexports.getExtensionScore = getExtensionScore;\n\nvar _scorer = require(\"./scorer\");\n\nvar tau_depth = 13; //  Directory depth at which the full path influence is halved.\nvar file_coeff = 1.2; //  Full path is also penalized for length of basename. This adjust a scale factor for that penalty.\n\nexports.default = {\n    score: score,\n    countDir: countDir,\n    getExtensionScore: getExtensionScore\n};\n\n//  Manage the logic of testing if there's a match and calling the main scoring function\n//  Also manage scoring a path and optional character.\n\nfunction score(string, query, options) {\n    var preparedQuery = options.preparedQuery,\n        allowErrors = options.allowErrors;\n\n    if (!allowErrors && !(0, _scorer.isMatch)(string, preparedQuery.core_lw, preparedQuery.core_up)) {\n        return 0;\n    }\n    var string_lw = string.toLowerCase();\n    var score = (0, _scorer.computeScore)(string, string_lw, options);\n    score = scorePath(string, string_lw, score, options);\n    return Math.ceil(score);\n}\n\n// \n//  Score adjustment for path\n// \n\nfunction scorePath(subject, subject_lw, fullPathScore, options) {\n\n    if (fullPathScore === 0) {\n        return 0;\n    }\n\n    var preparedQuery = options.preparedQuery,\n        useExtensionBonus = options.useExtensionBonus,\n        pathSeparator = options.pathSeparator;\n\n    //  Skip trailing slashes\n\n    var end = subject.length - 1;\n    while (subject[end] === pathSeparator) {\n        end--;\n    }\n\n    //  Get position of basePath of subject.\n    var basePos = subject.lastIndexOf(pathSeparator, end);\n    var fileLength = end - basePos;\n\n    //  Get a bonus for matching extension\n    var extAdjust = 1.0;\n\n    if (useExtensionBonus) {\n        extAdjust += getExtensionScore(subject_lw, preparedQuery.ext, basePos, end, 2);\n        fullPathScore *= extAdjust;\n    }\n\n    //  no basePath, nothing else to compute.\n    if (basePos === -1) {\n        return fullPathScore;\n    }\n\n    //  Get the number of folder in query\n    var depth = preparedQuery.depth;\n\n    //  Get that many folder from subject\n\n    while (basePos > -1 && depth-- > 0) {\n        basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n    }\n\n    //  Get basePath score, if BaseName is the whole string, no need to recompute\n    //  We still need to apply the folder depth and filename penalty.\n    var basePathScore = basePos === -1 ? fullPathScore : extAdjust * (0, _scorer.computeScore)(subject.slice(basePos + 1, end + 1), subject_lw.slice(basePos + 1, end + 1), options);\n\n    //  Final score is linear interpolation between base score and full path score.\n    //  For low directory depth, interpolation favor base Path then include more of full path as depth increase\n    //\n    //  A penalty based on the size of the basePath is applied to fullPathScore\n    //  That way, more focused basePath match can overcome longer directory path.\n\n    var alpha = 0.5 * tau_depth / (tau_depth + countDir(subject, end + 1, pathSeparator));\n    return alpha * basePathScore + (1 - alpha) * fullPathScore * (0, _scorer.scoreSize)(0, file_coeff * fileLength);\n}\n\n// \n//  Count number of folder in a path.\n//  (consecutive slashes count as a single directory)\n// \n\nfunction countDir(path, end, pathSeparator) {\n    if (end < 1) {\n        return 0;\n    }\n\n    var count = 0;\n    var i = -1;\n\n    // skip slash at the init so `foo/bar` and `/foo/bar` have the same depth.\n    while (++i < end && path[i] === pathSeparator) {}\n\n    while (++i < end) {\n        if (path[i] === pathSeparator) {\n            count++; // record first slash, but then skip consecutive ones\n            while (++i < end && path[i] === pathSeparator) {}\n        }\n    }\n\n    return count;\n}\n\n// \n//  Find fraction of extension that is matched by query.\n//  For example mf.h prefers myFile.h to myfile.html\n//  This need special handling because it give point for not having characters (the `tml` in above example)\n// \n\nfunction getExtension(str) {\n    var pos = str.lastIndexOf(\".\");\n    if (pos < 0) {\n        return \"\";\n    } else {\n        return str.substr(pos + 1);\n    }\n}\n\nfunction getExtensionScore(candidate, ext, startPos, endPos, maxDepth) {\n    //  startPos is the position of last slash of candidate, -1 if absent.\n\n    if (ext == null || !ext.length) {\n        return 0;\n    }\n\n    //  Check that (a) extension exist, (b) it is after the init of the basename\n    var pos = candidate.lastIndexOf(\".\", endPos);\n    if (pos <= startPos) {\n        return 0;\n    } //  (note that startPos >= -1)\n\n    var n = ext.length;\n    var m = endPos - pos;\n\n    //  n contain the smallest of both extension length, m the largest.\n    if (m < n) {\n        n = m;\n        m = ext.length;\n    }\n\n    // place cursor after dot & count number of matching characters in extension\n    pos++;\n    var matched = -1;\n    while (++matched < n) {\n        if (candidate[pos + matched] !== ext[matched]) {\n            break;\n        }\n    }\n\n    //  if nothing found, try deeper for multiple extensions, with some penalty for depth\n    if (matched === 0 && maxDepth > 0) {\n        return 0.9 * getExtensionScore(candidate, ext, startPos, pos - 2, maxDepth - 1);\n    }\n\n    //  cannot divide by zero because m is the largest extension length and we return if either is 0\n    return matched / m;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lib/pathScorer.js\n// module id = 4\n// module chunks = 0","\"use strict\";\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.isFunction = isFunction;\nexports.isArray = isArray;\nexports.getIterator = getIterator;\nexports.default = {\n    isFunction: isFunction,\n    isArray: isArray,\n    getIterator: getIterator\n};\nfunction isFunction(fn) {\n    return typeof fn === \"function\";\n}\n\nfunction isArray(tentativeArray) {\n\n    if (isFunction(Array.isArray)) {\n        return Array.isArray(tentativeArray);\n    }\n\n    return Object.prototype.toString.call(tentativeArray) === \"[object Array]\";\n}\n\n//\n// Es6 compatible iterator.\n// Follow convention of ImmutableJS\n//\n\nvar REAL_ITERATOR_SYMBOL = typeof Symbol === \"function\" && _typeof(Symbol.iterator) === \"symbol\" ? Symbol.iterator : null;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\n\nfunction getIterator(object) {\n\n    // Implement real es6 iterator\n    if (REAL_ITERATOR_SYMBOL != null && isFunction(object[REAL_ITERATOR_SYMBOL])) {\n        return object[REAL_ITERATOR_SYMBOL]();\n    }\n\n    // es6 like but does not support symbol\n    if (isFunction(object[REAL_ITERATOR_SYMBOL])) {\n        return object[FAUX_ITERATOR_SYMBOL]();\n    }\n\n    // object itself is an iterator ( instead of having an iterator getter )\n    //if(isFunction(object.next)){\n    //    return object;\n    //}\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lib/utils.js\n// module id = 5\n// module chunks = 0","'use strict';\n\nexports.__esModule = true;\nexports.match = match;\nexports.wrap = wrap;\n\nvar _scorer = require('./scorer');\n\nexports.default = {\n    match: match,\n    wrap: wrap\n};\n\n// Return position of character which matches\n\n// A match list is an array of indexes to characters that match.\n// This file should closely follow `scorer` except that it returns an array\n// of indexes instead of a score.\n\nfunction match(string, query, options) {\n    var allowErrors = options.allowErrors,\n        preparedQuery = options.preparedQuery,\n        pathSeparator = options.pathSeparator;\n\n\n    if (!allowErrors && !(0, _scorer.isMatch)(string, preparedQuery.core_lw, preparedQuery.core_up)) {\n        return [];\n    }\n    var string_lw = string.toLowerCase();\n\n    // Full path results\n    var matches = computeMatch(string, string_lw, preparedQuery);\n\n    //if there is no matches on the full path, there should not be any on the base path either.\n    if (matches.length === 0) {\n        return matches;\n    }\n\n    // Is there a base path ?\n    if (string.indexOf(pathSeparator) > -1) {\n\n        // Base path results\n        var baseMatches = basenameMatch(string, string_lw, preparedQuery, pathSeparator);\n\n        // Combine the results, removing duplicate indexes\n        matches = mergeMatches(matches, baseMatches);\n    }\n\n    return matches;\n}\n\n//\n// Wrap\n//\n// Helper around match if you want a string with result wrapped by some delimiter text\n\nfunction wrap(string, query, options) {\n\n    var tagClass = options.tagClass || 'highlight';\n    var tagOpen = options.tagOpen || '<strong class=\"' + tagClass + '\">';\n    var tagClose = options.tagClose || '</strong>';\n\n    if (string === query) {\n        return tagOpen + string + tagClose;\n    }\n\n    //Run get position where a match is found\n    var matchPositions = match(string, query, options);\n\n    //If no match return as is\n    if (matchPositions.length === 0) {\n        return string;\n    }\n\n    //Loop over match positions\n    var output = '';\n    var matchIndex = -1;\n    var strPos = 0;\n    while (++matchIndex < matchPositions.length) {\n        var matchPos = matchPositions[matchIndex];\n\n        // Get text before the current match position\n        if (matchPos > strPos) {\n            output += string.substring(strPos, matchPos);\n            strPos = matchPos;\n        }\n\n        // Get consecutive matches to wrap under a single tag\n        while (++matchIndex < matchPositions.length) {\n            if (matchPositions[matchIndex] === matchPos + 1) {\n                matchPos++;\n            } else {\n                matchIndex--;\n                break;\n            }\n        }\n\n        //Get text inside the match, including current character\n        matchPos++;\n        if (matchPos > strPos) {\n            output += tagOpen;\n            output += string.substring(strPos, matchPos);\n            output += tagClose;\n            strPos = matchPos;\n        }\n    }\n\n    //Get string after last match\n    if (strPos < string.length - 1) {\n        output += string.substring(strPos);\n    }\n\n    //return wrapped text\n    return output;\n}\n\nfunction basenameMatch(subject, subject_lw, preparedQuery, pathSeparator) {\n\n    // Skip trailing slashes\n    var end = subject.length - 1;\n    while (subject[end] === pathSeparator) {\n        end--;\n    }\n\n    // Get position of basePath of subject.\n    var basePos = subject.lastIndexOf(pathSeparator, end);\n\n    //If no PathSeparator, no base path exist.\n    if (basePos === -1) {\n        return [];\n    }\n\n    // Get the number of folder in query\n    var depth = preparedQuery.depth;\n\n    // Get that many folder from subject\n\n    while (depth-- > 0) {\n        basePos = subject.lastIndexOf(pathSeparator, basePos - 1);\n        if (basePos === -1) {\n            return [];\n        }\n    } //consumed whole subject ?\n\n    // Get basePath match\n    basePos++;\n    end++;\n    return computeMatch(subject.slice(basePos, end), subject_lw.slice(basePos, end), preparedQuery, basePos);\n}\n\n//\n// Combine two matches result and remove duplicate\n// (Assume sequences are sorted, matches are sorted by construction.)\n//\n\nfunction mergeMatches(a, b) {\n    var m = a.length;\n    var n = b.length;\n\n    if (n === 0) {\n        return a.slice();\n    }\n    if (m === 0) {\n        return b.slice();\n    }\n\n    var i = -1;\n    var j = 0;\n    var bj = b[j];\n    var out = [];\n\n    while (++i < m) {\n        var ai = a[i];\n\n        while (bj <= ai && ++j < n) {\n            if (bj < ai) {\n                out.push(bj);\n            }\n            bj = b[j];\n        }\n\n        out.push(ai);\n    }\n\n    while (j < n) {\n        out.push(b[j++]);\n    }\n\n    return out;\n}\n\n//----------------------------------------------------------------------\n\n//\n// Align sequence (used for fuzzaldrin.match)\n// Return position of subject characters that match query.\n//\n// Follow closely scorer.computeScore.\n// Except at each step we record what triggered the best score.\n// Then we trace back to output matched characters.\n//\n// Differences are:\n// - we record the best move at each position in a matrix, and finish by a traceback.\n// - we reset consecutive sequence if we do not take the match.\n// - no hit miss limit\n\n\nfunction computeMatch(subject, subject_lw, preparedQuery) {\n    var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var query = preparedQuery.query;\n    var query_lw = preparedQuery.query_lw;\n\n\n    var m = subject.length;\n    var n = query.length;\n\n    //this is like the consecutive bonus, but for camelCase / snake_case initials\n    var acro_score = (0, _scorer.scoreAcronyms)(subject, subject_lw, query, query_lw).score;\n\n    //Init\n    var score_row = new Array(n);\n    var csc_row = new Array(n);\n\n    // Directions constants\n    var STOP = 0;\n    var UP = 1;\n    var LEFT = 2;\n    var DIAGONAL = 3;\n\n    //Traceback matrix\n    var trace = new Array(m * n);\n    var pos = -1;\n\n    //Fill with 0\n    var j = -1; //0..n-1\n    while (++j < n) {\n        score_row[j] = 0;\n        csc_row[j] = 0;\n    }\n\n    var move = void 0;\n    var score_diag = void 0;\n    var score = void 0;\n    var score_up = void 0;\n    var csc_diag = void 0;\n\n    var i = -1; //0..m-1\n    while (++i < m) {\n        //foreach char si of subject\n\n        score = 0;\n        score_up = 0;\n        csc_diag = 0;\n\n        var si_lw = subject_lw[i];\n\n        j = -1; //0..n-1\n        while (++j < n) {\n            //foreach char qj of query\n\n            //reset score\n            var csc_score = 0;\n            var align = 0;\n            score_diag = score_up;\n\n            //Compute a tentative match\n            if (query_lw[j] === si_lw) {\n\n                var start = (0, _scorer.isWordStart)(i, subject, subject_lw);\n\n                // Forward search for a sequence of consecutive char\n                csc_score = csc_diag > 0 ? csc_diag : (0, _scorer.scoreConsecutives)(subject, subject_lw, query, query_lw, i, j, start);\n\n                // Determine bonus for matching A[i] with B[j]\n                align = score_diag + (0, _scorer.scoreCharacter)(i, j, start, acro_score, csc_score);\n            }\n\n            //Prepare next sequence & match score.\n            score_up = score_row[j]; // Current score_up is next run score diag\n            csc_diag = csc_row[j];\n\n            //In case of equality, moving UP get us closer to the init of the candidate string.\n            if (score > score_up) {\n                move = LEFT;\n            } else {\n                score = score_up;\n                move = UP;\n            }\n\n            // Only take alignment if it's the absolute best option.\n            if (align > score) {\n                score = align;\n                move = DIAGONAL;\n            } else {\n                //If we do not take this character, break consecutive sequence.\n                // (when consecutive is 0, it'll be recomputed)\n                csc_score = 0;\n            }\n\n            score_row[j] = score;\n            csc_row[j] = csc_score;\n            trace[++pos] = score > 0 ? move : STOP;\n        }\n    }\n\n    // -------------------\n    // Go back in the trace matrix\n    // and collect matches (diagonals)\n\n    i = m - 1;\n    j = n - 1;\n    pos = i * n + j;\n    var backtrack = true;\n    var matches = [];\n\n    while (backtrack && i >= 0 && j >= 0) {\n        switch (trace[pos]) {\n            case UP:\n                i--;\n                pos -= n;\n                break;\n            case LEFT:\n                j--;\n                pos--;\n                break;\n            case DIAGONAL:\n                matches.push(i + offset);\n                j--;\n                i--;\n                pos -= n + 1;\n                break;\n            default:\n                backtrack = false;\n        }\n    }\n\n    matches.reverse();\n    return matches;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lib/matcher.js\n// module id = 6\n// module chunks = 0","\"use strict\";\n\nexports.__esModule = true;\nexports.Query = undefined;\n\nvar _pathScorer = require(\"./pathScorer\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } } //\n// Query object\n//\n// Allow to reuse some quantities computed from query.\n// Optional char can optionally be specified in the form of a regular expression.\n//\n\n\nvar Query = exports.Query = function Query(query) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        optCharRegEx = _ref.optCharRegEx,\n        pathSeparator = _ref.pathSeparator;\n\n    _classCallCheck(this, Query);\n\n    if (query == null || !query.length) {\n        return;\n    }\n\n    this.query = query;\n    this.query_lw = query.toLowerCase();\n    this.core = coreChars(query, optCharRegEx);\n    this.core_lw = this.core.toLowerCase();\n    this.core_up = truncatedUpperCase(this.core);\n    this.depth = (0, _pathScorer.countDir)(query, query.length, pathSeparator);\n    this.ext = (0, _pathScorer.getExtension)(this.query_lw);\n    this.charCodes = getCharCodes(this.query_lw);\n};\n\n;\n\n//\n// Optional chars\n// Those char improve the score if present, but will not block the match (score=0) if absent.\n\nvar opt_char_re = /[ _\\-:\\/\\\\]/g;\n\nfunction coreChars(query, optCharRegEx) {\n\n    if (optCharRegEx == null) {\n        optCharRegEx = opt_char_re;\n    }\n\n    return query.replace(optCharRegEx, '');\n}\n\n//\n// Truncated Upper Case:\n// --------------------\n//\n// A fundamental mechanic is that we are able to keep uppercase and lowercase variant of the strings in sync.\n// For that we assume uppercase and lowercase version of the string have the same length. Of course unicode being unicode there's exceptions.\n// See ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt for the list\n//\n// \"Stra�e\".toUpperCase() -> \"STRASSE\"\n// truncatedUpperCase(\"Stra�e\") -> \"STRASE\"\n// iterating over every character, getting uppercase variant and getting first char of that.\n//\n\nfunction truncatedUpperCase(str) {\n    var upper = \"\";\n    for (var _iterator = str, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref2;\n\n        if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref2 = _iterator[_i++];\n        } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref2 = _i.value;\n        }\n\n        var char = _ref2;\n\n        upper += char.toUpperCase()[0];\n    }\n    return upper;\n}\n\n//\n// Get character codes:\n// --------------------\n//\n// Get character codes map for a given string\n//\n\nfunction getCharCodes(str) {\n    var len = str.length;\n    var i = -1;\n\n    var charCodes = [];\n    // create map\n    while (++i < len) {\n        charCodes[str.charCodeAt(i)] = true;\n    }\n\n    return charCodes;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/lib/query.js\n// module id = 7\n// module chunks = 0"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACrQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AChlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AClVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;","sourceRoot":""}